{"version":3,"sources":["webpack://snakey3/./src/base/game/Game.ts","webpack://snakey3/./src/base/floor/Coord.ts","webpack://snakey3/./src/base/floor/Tile.ts","webpack://snakey3/./src/base/floor/VisibleGrid.ts","webpack://snakey3/./src/base/lang/LangSeqTreeNode.ts","webpack://snakey3/./src/base/game/events/EventRecordEntry.ts","webpack://snakey3/./src/base/game/events/PlayerActionEvent.ts","webpack://snakey3/./src/base/floor/VisibleTile.ts","webpack://snakey3/./src/base/lang/Lang.ts","webpack://snakey3/./src/base/floor/TileGetter.ts","webpack://snakey3/./src/base/game/player/PlayerSkeleton.ts","webpack://snakey3/./src/base/game/player/Team.ts","webpack://snakey3/./src/base/game/player/PlayerStatus.ts","webpack://snakey3/./src/base/game/player/Player.ts","webpack://snakey3/./src/base/game/player/ArtificialPlayer.ts","webpack://snakey3/./src/base/lang/impl/English.ts","webpack://snakey3/./src/base/game/player/OperatorPlayer.ts","webpack://snakey3/./src/base/game/player/VisiblePlayerStatus.ts","webpack://snakey3/./src/base/floor/Grid.ts","webpack://snakey3/./src/base/floor/impl/Euclid2.ts","webpack://snakey3/./src/base/floor/impl/Beehive.ts","webpack://snakey3/./src/base/game/IndexTasks.ts","webpack://snakey3/./src/base/game/__gameparts/Base.ts","webpack://snakey3/./src/base/game/__gameparts/Events.ts","webpack://snakey3/./src/base/game/__gameparts/Manager.ts","webpack://snakey3/./src/client/OfflineGame.ts","webpack://snakey3/./src/base/game/player/artificials/Chaser.ts","webpack://snakey3/./src/client/ScratchMakeGame.ts"],"names":["Game","Type","CtorArgs","Serialization","Status","EVENT_NAME","Object","freeze","Coord","System","Abstract","desc","Mathy","prototype","coord","this","Id","NULL","evictOccupant","lastKnownUpdateId","freeHealth","setLangCharSeqPair","CharSeqPair","playerId","playerElem","occupantId","score","charSeqPair","char","seq","VisibleGrid","LangSeqTreeNode","EventRecordEntry","coordDesc","super","baseElem","document","createElement","classList","add","OmHooks","Tile","Class","BASE","pthbElem","POINTER_HB","appendChild","charElem","LANG_CHAR","General","FILL_PARENT","langCharElem","seqElem","LANG_SEQ","langSeqElem","parent","__setOccupant","newHealth","dataset","Dataset","HEALTH","toString","innerText","langChar","langSeq","getImplementation","coordSys","__Constructors","sequence","characters","children","forwardDict","reverseDict","Map","weightedChar","WeightedLangChar","weight","charArray","get","push","set","rootNode","Root","Array","from","sort","mappingA","mappingB","length","forEach","mapping","addCharMapping","finalize","validateConstruction","child","startsWith","Error","reset","inheritingHitCount","inheritingWeightedHitCount","i","Math","random","incrementNumHits","chars","Seq","REGEXP","test","RangeError","source","node","childNode","find","balancingScheme","slice","CMP","shift","pair","hitWeightedChar","__recursiveIncrementNumHits","weightInv","reduce","prev","curr","hitCount","upstreamNodes","leafNodes","__recursiveGetLeafNodes","map","simpleView","assign","create","hits","personalHitCount","kids","__proto__","undefined","LEAF_CMP","BalancingScheme","SEQ","a","b","CHAR","WEIGHT","PATH_CMP","averageCharHitCount","personalWeightedHitCount","TypeError","weightedHitCount","classIf","static","treeMap","CREATE_TREE_MAP","getLeafNodes","avoid","nodeToHit","leaf","andNonRootParents","conflictSeq","avoidSeq","splice","chooseOnePair","name","getName","getBlurb","root","EVENT_ID_REJECT","PlayerActionEvent","INITIAL_REQUEST_ID","Bubble","Movement","lastAcceptedRequestId","eventId","affectedNeighbours","playerLastAcceptedRequestId","destTile","newPlayerHealth","tilesWithHealthUpdates","dest","newCharSeqPair","newFreeHealth","TileGetter","args","__getTileAt","Query","__getTileDestsFrom","__getTileSourcesTo","contents","filter","tile","isOccupied","game","trunc","status","noCheckGameOver","TileGetterSource","spawnTile","hostTile","gameType","ONLINE","PlayerSkeleton","player","grid","at","destsFrom","sourcesTo","Team","teamId","members","id","every","member","ElimOrder","IMMORTAL","STANDING","elimOrder","teamElimOrder","health","newValue","oldIsDowned","isDowned","team","teams","numNonStandingTeams","statusBecomeOver","Username","username","familyId","requestInFlight","PLAYING","processMoveRequest","other","includes","Player","playerDescs","langName","teamIdCleaner","Set","originalId","squashedId","pda","pdb","playerDesc","index","socketId","ArtificialPlayer","langRemappingFunc","RemappingFunctions","event","key","seqBufferAcceptKey","unts","unoccupied","newSeqBuffer","seqBuffer","substring","possibleTarget","makeMovementRequest","visualBell","moveTo","spotlightElem","Grid","SPOTLIGHT","dOverlayElem","DOWNED_OVERLAY","dataDowned","DOWNED","colourizeTeamMembers","operator","FACE_SWATCH","movementContinueWithInitialDelay","cancelTimeout","scheduledMovementCallbackId","getUntToward","computeDesiredDestination","setTimeout","movementContinue","computeNextMovementTimer","of","English","Lowercase","entries","LETTER_FREQUENCY","accumulator","current","Names","ENGLISH__LOWERCASE","SINGLETON","seal","MixedCase","initializer","addMappings","charSeqTransform","cs","toLowerCase","toUpperCase","ENGLISH__MIXEDCASE","c","d","e","f","g","h","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","impl","gridClass","__getGridImplementation","tileClass","dimensions","gridDimensions","domParentHtmlIdHook","gridHtmlIdHook","__playerStatusCtor","playerStatusCtor","players","createPlayers","operatorIndex","teammateArray","PAUSED","gameDesc","languageName","playerIndex","Family","HUMAN","__createOperatorPlayer","__createArtifPlayer","csps","playerCoords","healthCoords","forEachTile","ser","__abstractNotifyThatGameStatusBecamePlaying","__abstractStatusBecomePlaying","focus","__abstractNotifyThatGameStatusBecamePaused","__abstractStatusBecomePaused","__abstractNotifyThatGameStatusBecameOver","__abstractStatusBecomeOver","OVER","eventRecord","doCheckOperatorSeqBuffer","clientEventLag","recordEvent","executeTileModificationsEvent","averageFreeHealth","averageFreeHealthPerTile","area","lang","getInstance","minLangLeaves","getAmbiguityThreshold","numLeaves","langBalancingScheme","currentFreeHealth","dryRunShuffleLangCharSeqAt","spawnPoints","getSpawnCoords","targetTile","flatMap","sourceToTarget","getNonConflictingChar","managerCheckGamePlayingRequest","processMoveExecute","dryRunSpawnFreeHealth","getNextUnusedEventId","bubbler","processBubbleExecute","OFFLINE","addEventListener","ev","processKeyboardInput","keyCode","preventDefault","callback","millis","handle","clearTimeout","getArea","gridImplElem","OHG","IMPL_BODY","parentElem","getElementById","COORD_SYS","GRID","TEXT_SELECT_DISABLED","querySelectorAll","remove","tabIndex","kbdDcIcon","querySelector","KBD_DC_ICON","Euclid2","round","sub","originOneNorm","abs","originInfNorm","max","originAxialAlignment","scalar","row","height","newRow","col","width","newTile","SIZE_LIMITS","consumer","thisArg","sourceCoord","intendedDest","options","some","equals","tileA","TileB","oneNorm","infNorm","axialAlignment","floor","radius","min","gridRow","playerCounts","dim","Visible","gridElem","style","setProperty","__addToDom","__VisibleGrid_super","Beehive","dash","bash","floorDash","floorBash","shorterSide","fslash","bslash","longerSide","IndexTasks","INIT_CLASS_REGISTRIES","VGr","AP","CHASER","statusBecomePlaying"],"mappings":"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","file":"1/index.js","sourcesContent":["import type { Lang } from \"lang/Lang\";\r\n\r\nimport type { Coord, Tile } from \"floor/Tile\";\r\nimport type { Grid } from \"floor/Grid\";\r\nimport type { Player, PlayerStatus } from \"./player/Player\";\r\n\r\n\r\n/**\r\n *\r\n *\r\n * These classes perform the majority of management over {@link Tile}\r\n * and {@link Player} objects. As a design choice, players can only join\r\n * a game before it starts, and actions such as changing the language or\r\n * difficulty require a restart. These actions that require a restart will\r\n * all be exposed to operators through a pre-game page. Other such actions\r\n * include: changing teams.\r\n *\r\n * There are overlaps between what each implementation needs to do:\r\n * - Offline and Server games maintain and control the master-game-state.\r\n * - Offline and Client games display the game-state to an operator via browser and HTML.\r\n * - Client  and Server games use network operations to communicate.\r\n */\r\nexport namespace Game {\r\n\r\n    export const enum Type {\r\n        SERVER  = \"SERVER\",\r\n        ONLINE  = \"ONLINE\",\r\n        OFFLINE = \"OFFLINE\",\r\n    }\r\n    export namespace Type {\r\n        export type Manager = Type.OFFLINE | Type.SERVER;\r\n    }\r\n\r\n    /**\r\n     * Unlike CtorArgs, these are not passed as no-prototype objects\r\n     * (possibly over the network) from the game manager to clients.\r\n     * These are abstract handles to game-implementation-dependant\r\n     * components.\r\n     */\r\n    export type ImplArgs<S extends Coord.System> = {\r\n        tileClass: Tile.ClassIf<S>,\r\n        playerStatusCtor: typeof PlayerStatus,\r\n    };\r\n\r\n    /**\r\n     * # Game Constructor Arguments\r\n     *\r\n     * @template S\r\n     * The coordinate system to use. The literal value must also be\r\n     * passed as the field `coordSys`.\r\n     */\r\n    export type CtorArgs<\r\n        G extends Game.Type,\r\n        S extends Coord.System,\r\n    > = Readonly<{\r\n        coordSys: S;\r\n        gridDimensions: Grid.Dimensions<S>;\r\n        gridHtmlIdHook: G extends Game.Type.SERVER ? undefined : string;\r\n\r\n        languageName: Lang.Names.Value[\"id\"];\r\n        langBalancingScheme: Lang.BalancingScheme;\r\n\r\n        /**\r\n         * The index in `playerDescs` of the operator's ctor args.\r\n         */\r\n        operatorIndex: G extends Game.Type.SERVER\r\n            ? undefined\r\n            : Player.Id;\r\n        playerDescs: TU.RoArr<(\r\n            G extends Game.Type.Manager\r\n            ? Player.CtorArgs.PreIdAssignment\r\n            : Player.CtorArgs\r\n        )>;\r\n\r\n        averageFreeHealthPerTile: Player.Health;\r\n    }>;\r\n\r\n    export namespace CtorArgs {\r\n\r\n        export const EVENT_NAME = \"game-create\";\r\n\r\n        /**\r\n         * Not used here, but used in {@link GroupSession#createGameInstance}.\r\n         */\r\n        export type FailureReasons = {\r\n            undefinedUsername: TU.RoArr<Player.SocketId>; // socket ID's\r\n            undefinedTeamId:   TU.RoArr<Player.SocketId>;\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Serialization of the Game State after a reset.\r\n     *\r\n     * Only contains state information that would not be known by a\r\n     * non-Game Manager.\r\n     */\r\n    export type ResetSer<S extends Coord.System> = Readonly<{\r\n        csps: TU.RoArr<Lang.CharSeqPair>;\r\n        playerCoords: TU.RoArr<Coord.Bare<S>>;\r\n        healthCoords: TU.RoArr<{\r\n            coord: Coord.Bare<S>;\r\n            health: Player.Health;\r\n        }>;\r\n    }>;\r\n    export namespace Serialization {\r\n        export const EVENT_NAME = <const>\"game-reset\";\r\n    }\r\n\r\n    /**\r\n     * - **`PLAYING`** can go to:\r\n     *   - `PAUSED`: when a pause request initiated by a player is accepted.\r\n     *   - `OVER`:  when certain conditions of players being downed are met.\r\n     * - **`PAUSED`** can go to:\r\n     *   - `PLAYING`: similar to PLAYING->PAUSED.\r\n     * - **`OVER`** can go to:\r\n     *   - `PLAYING`: via resetting the game.\r\n     */\r\n    export const enum Status {\r\n        PLAYING = \"PLAYING\",\r\n        PAUSED  = \"PAUSED\",\r\n        OVER    = \"OVER\",\r\n    }\r\n}\r\nObject.freeze(Game);\r\n","import type { Euclid2 } from \"./impl/Euclid2\";\r\nimport type { Beehive } from \"./impl/Beehive\";\r\n\r\n\r\n/**\r\n * Done manually so that grid implementations can use their coordinate\r\n * implementation's non-standard methods safely on coordinates retrieved\r\n * from Grid tiles.\r\n */\r\nexport type Coord<S extends Coord.System> = (Coord.Bare<S>) &\r\n    ( S extends Coord.System.EUCLID2 ? Euclid2.Coord\r\n    : S extends Coord.System.BEEHIVE ? Beehive.Coord\r\n    : never\r\n    );\r\n\r\n/**\r\n *\r\n */\r\nexport namespace Coord {\r\n\r\n    export const enum System {\r\n        EUCLID2 = \"EUCLID2\",\r\n        BEEHIVE = \"BEEHIVE\",\r\n    }\r\n\r\n    export type Bare<S extends System> =\r\n    ( S extends System.EUCLID2 ? Euclid2.Coord.Bare\r\n    : S extends System.BEEHIVE ? Beehive.Coord.Bare\r\n    : never\r\n    );\r\n\r\n    // ==============================================================\r\n    // Note: The below exports do not require any modifications with\r\n    // the additions of new coordinate systems.\r\n    // ==============================================================\r\n\r\n    /**\r\n     * Immutable. All `Coord` objects returned by operations are new objects.\r\n     *\r\n     * @template S - An enum identifying the unique implementation class.\r\n     */\r\n    export abstract class Abstract<S extends Coord.System> {\r\n\r\n        /**\r\n         * This does nothing. Subclass constructors should copy in the\r\n         * fields specified by `desc` and end with a self-freezing call.\r\n         *\r\n         * @param desc - Untouched. Here as a reminder of what is needed.\r\n         */\r\n        protected constructor(desc: Coord.Bare<S>) {\r\n            desc; // Prevents warning about unused parameter.\r\n        }\r\n\r\n        public abstract equals(other: Coord.Bare<S>): boolean;\r\n    }\r\n\r\n    export namespace Abstract {\r\n        /**\r\n         * As opposed, for example, to grid systems operating on the\r\n         * basis of graph connections that cannot be represented by\r\n         * lattices.\r\n         */\r\n        export abstract class Mathy<S extends Coord.System> extends Coord.Abstract<S> {\r\n            /**\r\n             * For discrete-coordinate-based systems, this is used to round\r\n             * non-discrete coordinates to discrete ones.\r\n             */\r\n            public abstract round(): Coord<S>;\r\n\r\n            public abstract add(other: Coord.Bare<S>): Coord<S>;\r\n            public abstract sub(other: Coord.Bare<S>): Coord<S>;\r\n            public abstract mul(scalar: number): Coord<S>;\r\n        }\r\n    }\r\n    Object.freeze(Abstract);\r\n    Object.freeze(Abstract.prototype);\r\n\r\n}\r\nObject.freeze(Coord);\r\n// No prototype to freeze.\r\n","import { Lang, Player } from \"utils/TypeDefs\";\r\nimport { Coord } from \"./Coord\";\r\nexport { Coord };\r\n\r\n\r\n/**\r\n * # The Tile Class\r\n *\r\n * As an implementation choice, tiles are dumb. That is, they have\r\n * no knowledge of their context. Their internals are all managed by\r\n * their host {@link Game} through method calls.\r\n *\r\n * From a caller's point of view, extending classes should have am\r\n * identical constructor signature as that of this base class. This\r\n * can be done by a type assertion statement: `<extension class> as\r\n * Tile.ConstructorType<any>`.\r\n *\r\n * @template S\r\n * The coordinate system enum for this tile's coordinate.\r\n */\r\nexport class Tile<S extends Coord.System> {\r\n\r\n    public readonly coord: Coord<S>;\r\n    #occupantId: Player.Id.Nullable;\r\n    #freeHealth: Player.Health;\r\n    #langChar:  Lang.Char;\r\n    #langSeq:   Lang.Seq;\r\n\r\n    /**\r\n     * The number of times this `Tile` was occupied since the last\r\n     * reset. This is used to ensure that in online sessions, each\r\n     * client has a synchronized copy of the game. The Game Manager\r\n     * will drop requests for movements made by players who made the\r\n     * request at a time when they had not yet received information\r\n     * related to the game-state in affected-zones of their request.\r\n     */\r\n    public lastKnownUpdateId: number;\r\n\r\n    /**\r\n     * _Does not call reset._\r\n     *\r\n     * @param coord -\r\n     */\r\n    public constructor(coord: Coord<S>) {\r\n        this.coord = coord;\r\n        this.#occupantId = Player.Id.NULL;\r\n    }\r\n\r\n    public reset(): void {\r\n        this.evictOccupant();\r\n        this.lastKnownUpdateId = 0;\r\n        this.freeHealth = 0;\r\n\r\n        // This is also done when shuffling individual tiles throughout\r\n        // the game, but it is done here since initially, nothing needs\r\n        // to be avoided because no CSP's have been set yet.\r\n        this.setLangCharSeqPair(Lang.CharSeqPair.NULL);\r\n    }\r\n\r\n    /**\r\n     * Called, for example, when a {@link Player} on this `Tile` provides\r\n     * input that did not work to complete their {@link Player#seqBuffer}\r\n     * against any neighbouring `Tile`s.\r\n     */\r\n    public visualBell(): void {\r\n        // does nothing by default.\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Any overrides must make a supercall to this implementation.\r\n     *\r\n     * @param playerId -\r\n     */\r\n    public __setOccupant(playerId: Player.Id, playerElem?: HTMLElement): void {\r\n        this.#occupantId = playerId;\r\n    }\r\n\r\n    public get isOccupied(): boolean {\r\n        return this.occupantId !== Player.Id.NULL;\r\n    }\r\n\r\n    public evictOccupant(): void {\r\n        this.#occupantId = Player.Id.NULL;\r\n    }\r\n\r\n    public get occupantId(): Player.Id.Nullable {\r\n        return this.#occupantId;\r\n    }\r\n\r\n\r\n\r\n    public get freeHealth(): Player.Health {\r\n        return this.#freeHealth;\r\n    }\r\n\r\n    public set freeHealth(score: Player.Health) {\r\n        this.#freeHealth = score;\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public setLangCharSeqPair(charSeqPair: Lang.CharSeqPair): void {\r\n        this.#langChar = charSeqPair.char;\r\n        this.#langSeq  = charSeqPair.seq;\r\n    }\r\n\r\n    public get langChar(): Lang.Char {\r\n        return this.#langChar;\r\n    }\r\n\r\n    public get langSeq(): Lang.Seq {\r\n        return this.#langSeq;\r\n    }\r\n\r\n}\r\n// If this errs when changing the constructor signature, then\r\n// the type definition being asserted should be updated to match.\r\nTile as Tile.ClassIf<any>;\r\n\r\n\r\n\r\nexport namespace Tile {\r\n\r\n    // NOTE: We need this for type-safety because just using typeof\r\n    // will not capture information about type arguments.\r\n    export type ClassIf<S extends Coord.System> = {\r\n        new(coord: Tile<S>[\"coord\"]): Tile<S>;\r\n    };\r\n\r\n}\r\nObject.freeze(Tile);\r\nObject.freeze(Tile.prototype);\r\n","import type { Coord, Tile } from \"floor/Tile\";\r\nimport { Grid } from \"floor/Grid\";\r\n\r\n\r\n/**\r\n * All implementations must call `Grid.__VisibleGrid_super` at the end\r\n * of their constructors.\r\n *\r\n * NOTE: As a design choice, this is put in a separate file from the\r\n * base `Grid` class with a _separate_ dictionary of implementation\r\n * literals so that the build tooling can infer that this code can\r\n * be excluded (tree shaking). The implementations may still go in\r\n * the same file as their non-visible implementation since they are\r\n * separate exports (this can be tree-shaken). Specifically, the\r\n * _server_ related code will benefit from this choice since it will\r\n * not use\r\n */\r\nexport interface VisibleGrid<S extends Coord.System> extends Grid<S> {\r\n\r\n    /**\r\n     * Contains the implementation-dependant HTML representation of\r\n     * the grid.\r\n     */\r\n    readonly baseElem: HTMLElement;\r\n\r\n    // This is just a reminder to the developer that such a function\r\n    // exists and is an important part of the architecture. Since\r\n    // VisibleGrid can't be a class (no multiple inheritance), this\r\n    // part of a VisibleGrid's constructor sequence is implemented\r\n    // in Grid.\r\n    __VisibleGrid_super(desc: Grid.CtorArgs<S>, domGrid: HTMLElement): void;\r\n}\r\n\r\n\r\nexport namespace VisibleGrid {\r\n\r\n    export interface ClassIf<S extends Coord.System> extends Grid.ClassIf<S> {\r\n        /**\r\n         * @override\r\n         */\r\n        new(desc: Grid.CtorArgs<S>): VisibleGrid<S>;\r\n    };\r\n\r\n    // Each implementation must register itself into this dictionary.\r\n    export declare const __Constructors: {\r\n        readonly [ S in Coord.System ]: Grid.ClassIf<S>\r\n    };\r\n\r\n    export const getImplementation = <S extends Coord.System>(coordSys: S): ClassIf<S> => {\r\n        const ctor = __Constructors[coordSys];\r\n        return ctor as unknown as ClassIf<S>;\r\n    };\r\n}\r\n","import { Lang as __Lang } from \"utils/TypeDefs\";\r\nimport type { Lang } from \"./Lang\";\r\n\r\n\r\ntype SorterMap<T> = Readonly<Record<Lang.BalancingScheme, (a: T, b: T) => number>>;\r\n\r\n/**\r\n * No `LangSeqTreeNode`s mapped in the `children` field have an empty\r\n * `characters` collection (with the exception of the root node). The\r\n * root node should have a falsy parent, and the `empty string` as its\r\n * `sequence` field, with a correspondingly empty `characters` collection.\r\n *\r\n * All non-root nodes have a `sequence` that is prefixed by their parent's\r\n * `sequence`, and a non-empty `characters` collection.\r\n *\r\n * The enclosing {@link Lang} object has no concept of `LangChar` weights.\r\n * All it has is the interfaces provided by the hit-count getter methods.\r\n */\r\nexport class LangSeqTreeNode<ROOT extends boolean = false> {\r\n\r\n    public readonly sequence:   ROOT extends true ? \"\" : Lang.Seq;\r\n    public readonly characters: TU.RoArr<WeightedLangChar>; // Frozen.\r\n    public readonly parent:     ROOT extends true ? undefined : LangSeqTreeNode;\r\n    public readonly children:   Array<LangSeqTreeNode>; // Frozen.\r\n\r\n    // These fields use weak privacy to leave room for testing and\r\n    // debugging by inspection. They have no getters.\r\n    /**\r\n     * Equals this node's own hit count plus all its ancestors' hit\r\n     * counts.\r\n     */\r\n    private inheritingHitCount: number;\r\n    /**\r\n     * Equals this node's own weighted hit count plus all its ancestors'\r\n     * weighted hit counts.\r\n     */\r\n    private inheritingWeightedHitCount: number;\r\n\r\n\r\n    /**\r\n     * _Does not call reset._\r\n     *\r\n     * @param forwardDict -\r\n     * @returns The root node of a new tree map.\r\n     */\r\n    public static CREATE_TREE_MAP(forwardDict: Lang.CharSeqPair.WeightedForwardMap): LangSeqTreeNode<true> {\r\n        // Reverse the map:\r\n        const reverseDict: Map<Lang.Seq, Array<WeightedLangChar>> = new Map();\r\n        for (const char in forwardDict) {\r\n            const seq = forwardDict[char].seq;\r\n            const weightedChar = new WeightedLangChar(\r\n                char, forwardDict[char].weight,\r\n            );\r\n            const charArray = reverseDict.get(seq);\r\n            if (charArray) {\r\n                // The entry was already made:\r\n                charArray.push(weightedChar);\r\n            } else {\r\n                reverseDict.set(seq, [weightedChar,]);\r\n            }\r\n        }\r\n        // Add mappings in ascending order of sequence length:\r\n        // (this is so that no merging of branches needs to be done)\r\n        const rootNode = new LangSeqTreeNode.Root();\r\n        Array.from(reverseDict)\r\n          //.sort((mappingA, mappingB) => mappingA[0].localeCompare(mappingB[0]))\r\n            .sort((mappingA, mappingB) => mappingA[0].length - mappingB[0].length)\r\n            .forEach((mapping) => {\r\n                rootNode.addCharMapping(...mapping);\r\n            });\r\n        rootNode.finalize();\r\n        return rootNode;\r\n    }\r\n\r\n    protected constructor(\r\n        parent:     LangSeqTreeNode<ROOT>[\"parent\"],\r\n        sequence:   LangSeqTreeNode<ROOT>[\"sequence\"],\r\n        characters: ROOT extends true ? readonly [] : TU.RoArr<WeightedLangChar>,\r\n    ) {\r\n        this.sequence   = sequence;\r\n        this.characters = characters;\r\n        this.parent     = parent;\r\n        this.children   = [];\r\n    }\r\n\r\n    private finalize(): void {\r\n        this.validateConstruction();\r\n        Object.freeze(this.characters);\r\n        Object.freeze(this.children);\r\n        this.children.forEach((child) => child.finalize());\r\n    }\r\n\r\n    // TODO.test move this to only be run in tests?\r\n    protected validateConstruction(): void | never {\r\n        if (!(this.sequence.startsWith(this.parent!.sequence))) {\r\n            throw new Error(\"Child node's sequence must start with that of its parent.\");\r\n        }\r\n    }\r\n\r\n    public reset(): void {\r\n        // Recursively reset (from leaves first to root last):\r\n        // We must go in such an order so that our random hit\r\n        // seeds will be properly inherited (and not wrongly\r\n        // cleared).\r\n        this.children.forEach((child) => child.reset());\r\n\r\n        this.inheritingHitCount = 0;\r\n        this.inheritingWeightedHitCount = 0.000;\r\n        this.characters.forEach((char) => {\r\n            char.reset();\r\n            // Seed with properly-weight-distributed hit counts\r\n            // for a uniformly distributed random number of times.\r\n            // The choice of the upper bound on the number of times\r\n            // is rather arbitrary, but it should not be too small.\r\n            for (let i = 0; i < Math.random() * 10; i++) {\r\n                this.incrementNumHits(char);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param seq The typeable sequence corresponding to entries of `chars`.\r\n     * @param chars A collection of unique characters in a written language.\r\n     */\r\n    protected addCharMapping(seq: Lang.Seq, chars: TU.RoArr<WeightedLangChar>): void {\r\n        if (!(__Lang.Seq.REGEXP.test(seq))) {\r\n            throw new RangeError(`Mapping-sequence \\\"${seq}\\\" did not match the`\r\n            + ` required regular expression \\\"${__Lang.Seq.REGEXP.source}\\\".`\r\n            );\r\n        } else if (chars.length === 0) {\r\n            throw new Error(\"Must not make mapping without written characters.\");\r\n        }\r\n        let node: LangSeqTreeNode<any> = this; {\r\n            let childNode: LangSeqTreeNode<any> | undefined = this;\r\n            while (childNode) {\r\n                node = childNode;\r\n                childNode = childNode.children.find((child) => seq.startsWith(child.sequence));\r\n            }\r\n        }\r\n        if (node.sequence === seq) {\r\n            // This should never happen.\r\n            throw new Error(`Mappings for all written-characters with a common`\r\n            + `corresponding typeable-sequence should be registered together,`\r\n            + `but an existing mapping for the sequence \\\"${seq}\\\" was found.`\r\n            );\r\n        }\r\n        node.children.push(new LangSeqTreeNode(node, seq, chars));\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Incrementing the hit-count makes this node less likely to be\r\n     * used for a shuffle-in. Shuffle-in option searching is easy to\r\n     * taking the viewpoint of leaf-nodes, so this implementation is\r\n     * geared toward indicating hit-count through leaf-nodes, hence\r\n     * the bubble-down of hit-count incrementation.\r\n     *\r\n     * @param balancingScheme -\r\n     * @returns A character / sequence pair from this node that has\r\n     *      been selected the least according to the specified scheme.\r\n     */\r\n    public chooseOnePair(balancingScheme: Lang.BalancingScheme): Lang.CharSeqPair {\r\n        const weightedChar = this.characters.slice(0)\r\n            .sort(WeightedLangChar.CMP[balancingScheme])\r\n            .shift()!;\r\n        const pair: Lang.CharSeqPair = {\r\n            char: weightedChar.char,\r\n            seq:  this.sequence,\r\n        };\r\n        this.incrementNumHits(weightedChar);\r\n        return pair;\r\n    }\r\n    private incrementNumHits(hitWeightedChar: WeightedLangChar): void {\r\n        hitWeightedChar.incrementNumHits();\r\n        this.__recursiveIncrementNumHits(hitWeightedChar.weightInv);\r\n    }\r\n    private __recursiveIncrementNumHits(weightInv: number): void {\r\n        this.inheritingHitCount += 1;\r\n        this.inheritingWeightedHitCount += weightInv;\r\n        this.children.forEach((child) => child.__recursiveIncrementNumHits(weightInv));\r\n    }\r\n\r\n    /**\r\n     * Do not call this on a root node.\r\n     *\r\n     * @returns How many hits were made on this node since the last reset.\r\n     */\r\n    protected get personalHitCount(): number {\r\n        return this.inheritingHitCount - (this.parent!).inheritingHitCount;\r\n    }\r\n\r\n    protected get averageCharHitCount(): number {\r\n        return (\r\n            this.characters.reduce<number>((prev, curr) => prev + curr.hitCount, 0)\r\n            / this.characters.length\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Do not call this on a root node.\r\n     *\r\n     * @returns How many hits were made on this node since the last reset.\r\n     */\r\n    protected get personalWeightedHitCount(): number {\r\n        return this.inheritingWeightedHitCount - (this.parent!).inheritingWeightedHitCount;\r\n    }\r\n\r\n    public andNonRootParents(): Array<LangSeqTreeNode> {\r\n        const upstreamNodes: Array<LangSeqTreeNode> = [];\r\n\r\n        let node = this as LangSeqTreeNode;\r\n        while (node.parent) {\r\n            upstreamNodes.push(node);\r\n            node = node.parent;\r\n        }\r\n        return upstreamNodes;\r\n    }\r\n\r\n    public getLeafNodes(): Array<LangSeqTreeNode> {\r\n        const leafNodes: Array<LangSeqTreeNode> = [];\r\n        this.__recursiveGetLeafNodes(leafNodes);\r\n        return leafNodes;\r\n    }\r\n    private __recursiveGetLeafNodes(leafNodes: Array<LangSeqTreeNode>): void {\r\n        if (this.children.length) {\r\n            this.children.forEach((child) => {\r\n                child.__recursiveGetLeafNodes(leafNodes);\r\n            });\r\n        } else {\r\n            leafNodes.push(this as LangSeqTreeNode);\r\n        }\r\n    }\r\n\r\n\r\n\r\n    public simpleView(): object {\r\n        let chars = this.characters.map((char) => char.simpleView());\r\n        return Object.assign(Object.create(null), {\r\n            seq: this.sequence,\r\n            chars: (chars.length === 1) ? chars[0] : chars,\r\n            hits: this.personalHitCount,\r\n            kids: this.children.map((child) => child.simpleView()),\r\n            __proto__: undefined,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @param a -\r\n     * @param b -\r\n     * @returns -\r\n     */\r\n    public static readonly LEAF_CMP: SorterMap<LangSeqTreeNode> = Object.freeze({\r\n        [ __Lang.BalancingScheme.SEQ ]:    ((a, b) => a.inheritingHitCount - b.inheritingHitCount),\r\n        [ __Lang.BalancingScheme.CHAR ]:   ((a, b) => a.inheritingHitCount - b.inheritingHitCount),\r\n        [ __Lang.BalancingScheme.WEIGHT ]: ((a, b) => a.inheritingWeightedHitCount - b.inheritingWeightedHitCount),\r\n    });\r\n\r\n    /**\r\n     * @param a -\r\n     * @param b -\r\n     * @returns -\r\n     */\r\n    public static readonly PATH_CMP: SorterMap<LangSeqTreeNode> = Object.freeze({\r\n        [ __Lang.BalancingScheme.SEQ ]:    ((a, b) => a.personalHitCount - b.personalHitCount),\r\n        [ __Lang.BalancingScheme.CHAR ]:   ((a, b) => a.averageCharHitCount - b.averageCharHitCount),\r\n        [ __Lang.BalancingScheme.WEIGHT ]: ((a, b) => a.personalWeightedHitCount - b.personalWeightedHitCount),\r\n    });\r\n\r\n}\r\n\r\n\r\nexport namespace LangSeqTreeNode {\r\n    export class Root extends LangSeqTreeNode<true> {\r\n        public constructor() {\r\n            super(undefined, \"\", []);\r\n        }\r\n        public validateConstruction(): void {\r\n            // nothing.\r\n        }\r\n        public chooseOnePair(balancingScheme: Lang.BalancingScheme): never {\r\n            throw new TypeError(\"Must never hit on the root.\");\r\n        }\r\n        protected get personalHitCount(): number {\r\n            throw new TypeError(\"Must never hit on the root.\");\r\n        }\r\n        protected get personalWeightedHitCount(): never {\r\n            throw new TypeError(\"Must never hit on the root.\");\r\n        }\r\n        public andNonRootParents(): never {\r\n            throw new TypeError();\r\n        }\r\n        public simpleView(): object {\r\n            return this.children.map((child) => child.simpleView());\r\n        }\r\n    }\r\n}\r\nObject.freeze(LangSeqTreeNode);\r\nObject.freeze(LangSeqTreeNode.prototype);\r\n\r\n\r\n\r\n/**\r\n * Has no concept of an associated typeable sequence. Used to associate\r\n * a written character to a relative frequency of occurrence in samples\r\n * of writing, and to keep a counter for how many times this character\r\n * has been shuffled-in in the current game session.\r\n *\r\n * Not exported.\r\n */\r\nclass WeightedLangChar {\r\n\r\n    public readonly char: Lang.Char;\r\n\r\n    /**\r\n     * A weight is relative to weights of other unique characters in\r\n     * the contextual language. A character with a higher weight, when\r\n     * using the {@link BalancingScheme#WEIGHT} scheme, will have a\r\n     * higher shuffle-in priority than characters with a lower weight.\r\n     *\r\n     * Specifically, using the {@link BalancingScheme#WEIGHT} scheme,\r\n     * a character `cA` with a weight `N` times that of another `cB`\r\n     * will, on average, be returned `N` times more often by the\r\n     * {@link LangSeqTreeNode#chooseOnePair} method than `cB`.\r\n     *\r\n     * This is implemented using counters that last for the lifetime\r\n     * of one game, and increment for a chosen character by the inverse\r\n     * of its weight every time it is chosen. Choosing the character\r\n     * with the lowest such counter at a given time will produce the\r\n     * desired effect:\r\n     *\r\n     * If there are three characters mapped with weights `cA: 1`, `cB:\r\n     * 2`, `cC: 3`, and share no prefixing substrings and we pretend\r\n     * that there are never any sequences to avoid when shuffling in\r\n     * characters, then the results of consecutive calls should produce\r\n     * something like: `A(0), B(0), C(0), A(1/3), B(1/2), A(2/3),\r\n     * (repeat forever)`, where the bracketed values are their weighted\r\n     * hit-counts before they were returned, since the last reset.\r\n     */\r\n    public readonly weightInv: number;\r\n    public hitCount: number;\r\n    public weightedHitCount: number;\r\n\r\n    public constructor(\r\n        char: Lang.Char,\r\n        weight: number,\r\n    ) {\r\n        if (weight <= 0) {\r\n            throw new RangeError(`All weights must be positive, but we`\r\n            + ` were passed the value \\\"${weight}\\\" for the character`\r\n            + ` \\\"${char}\\\".`);\r\n        }\r\n        this.char = char;\r\n        this.weightInv = 1.000 / weight;\r\n        // The above choice of a numerator is not behaviourally significant.\r\n        // All that is required is that all single-mappings in a `Lang` use\r\n        // a consistent value.\r\n    }\r\n\r\n    public reset(): void {\r\n        this.hitCount = 0;\r\n        this.weightedHitCount = 0.000;\r\n    }\r\n\r\n    public incrementNumHits(): void {\r\n        this.hitCount += 1;\r\n        this.weightedHitCount += this.weightInv;\r\n    }\r\n\r\n    public simpleView(): object {\r\n        return Object.assign(Object.create(null), {\r\n            char: this.char,\r\n            hits: this.hitCount,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @param a -\r\n     * @param b -\r\n     * @returns -\r\n     */\r\n    public static readonly CMP: SorterMap<WeightedLangChar> = Object.freeze({\r\n        [ __Lang.BalancingScheme.SEQ ]:    (a, b) => a.hitCount - b.hitCount, // design choice.\r\n        [ __Lang.BalancingScheme.CHAR ]:   (a, b) => a.hitCount - b.hitCount,\r\n        [ __Lang.BalancingScheme.WEIGHT ]: (a, b) => a.weightedHitCount - b.weightedHitCount,\r\n    });\r\n};\r\nObject.freeze(WeightedLangChar);\r\nObject.freeze(WeightedLangChar.prototype);\r\n","import type { Player } from \"game/player/Player\";\r\n\r\n\r\n/**\r\n *\r\n */\r\nexport interface EventRecordEntry {\r\n    /**\r\n     * A positive, integer-valued identifier for an event.\r\n     *\r\n     * Must be unique in its context.\r\n     *\r\n     * The request-maker should make the request with this set to.\r\n     * {@link EVENT_ID_REJECT}.\r\n     */\r\n    eventId: number;\r\n}\r\nexport namespace EventRecordEntry {\r\n    /**\r\n     * The Game Manager should assign this value to the `eventId` field\r\n     * of a request-type event to signal if a request has been rejected.\r\n     * It is convenient to use as a default value.\r\n     */\r\n    export const EVENT_ID_REJECT = -1;\r\n}\r\nObject.freeze(EventRecordEntry);\r\n\r\n\r\n/**\r\n *\r\n */\r\nexport interface PlayerGeneratedRequest extends EventRecordEntry {\r\n\r\n    readonly playerId: Player.Id;\r\n\r\n    /**\r\n     * ### Client Request\r\n     *\r\n     * Requester sends this desc to the Game Manager with a value of\r\n     * the ID of the last request it that the server _accepted_. This\r\n     * naturally implies that a requester cannot send a new request to\r\n     * the Game Manager until it has received the Game Manager's\r\n     * response to the last request it made.\r\n     *\r\n     * ### Server Response\r\n     *\r\n     * If the server accepts the request, it must broadcast a response\r\n     * with this field set to the incremented value.\r\n     *\r\n     * If it rejects this request, it must directly acknowledge its\r\n     * receipt of the request (no need to broadcast to all clients)\r\n     * with this field unchanged, which indicates a rejection of the\r\n     * request.\r\n     *\r\n     * ### Handling Unexpected Values\r\n     *\r\n     * If the server / Game Manager receives a request with a value in\r\n     * this field lower than the one it set in its last response to the\r\n     * requester, this would mean that the requester didn't wait for a\r\n     * response to its previous request, which it is not supposed to do.\r\n     *\r\n     * **Important:** If the above requirement is ever changed, (in\r\n     * addition to other mechanisms I haven't reasoned through,) this\r\n     * field's spec should change to require _all_ server responses to\r\n     * have this field set to an incremented value, including rejects.\r\n     *\r\n     * The server should never receive a request with a value higher\r\n     * than the one it provided in its last response to this requester\r\n     * because it in charge of incrementing it- the client should only\r\n     * change the value it sees to match the one from the server's\r\n     * response.\r\n     *\r\n     * In both these cases, the server may throw an assertion error for\r\n     * debugging purposes.\r\n     */\r\n    playerLastAcceptedRequestId: number;\r\n};\r\n","import type { Lang } from \"lang/Lang\";\r\nimport type { Coord, Tile } from \"floor/Tile\";\r\nimport type { Player } from \"game/player/Player\";\r\nimport { EventRecordEntry, PlayerGeneratedRequest } from \"./EventRecordEntry\";\r\n\r\n\r\nexport type TileModificationEvent<S extends Coord.System> = {\r\n    readonly coord: Coord.Bare<S>;\r\n\r\n    /**\r\n     * The requester should set this field to the highest value they\r\n     * received from any previous responses from the server. In normal\r\n     * cases (no message reordering), this should be equal to the last\r\n     * value seen in the response from the server.\r\n     *\r\n     * The server should respond with the increment of this value. A\r\n     * movement event causes a shuffle-in at the destination position,\r\n     * which can affect whether another player intending to move to\r\n     * the same position can do so. For this reason, the server should\r\n     * reject requests where the requester has not received changes\r\n     * involving a shuffle-in at their desired destination. This is\r\n     * not mandatory, but preferred behaviour.\r\n     */\r\n    lastKnownUpdateId: number;\r\n\r\n    newFreeHealth?: Player.Health;\r\n\r\n    /**\r\n     * Any value assigned by the requester to this field should be\r\n     * ignored by the server.\r\n     *\r\n     * The server must set this to describe the new values to be\r\n     * shuffled-in to the destination tile. It may set the field\r\n     * to `undefined` if it wants to leave the CSP unchanged.\r\n     */\r\n    newCharSeqPair?: Lang.CharSeqPair;\r\n};\r\n\r\n\r\n\r\nexport namespace PlayerActionEvent {\r\n\r\n    /**\r\n     * This is the agreed upon value that both the server and client\r\n     * copies of a game should set as the initial value for request id\r\n     * counters. Remember that a request ID is a property of a player,\r\n     * whereas an event ID is a property tied to a game.\r\n     */\r\n    export const INITIAL_REQUEST_ID = -1;\r\n\r\n    export const EVENT_NAME = Object.freeze(<const>{\r\n        Bubble:   \"player-bubble\"  ,\r\n        Movement: \"player-movement\",\r\n    });\r\n\r\n\r\n    /**\r\n     *\r\n     */\r\n    export class Bubble implements PlayerGeneratedRequest {\r\n\r\n        public eventId: number = EventRecordEntry.EVENT_ID_REJECT;\r\n\r\n        public readonly playerId: Player.Id;\r\n\r\n        /**\r\n         * @see Player#lastAcceptedRequestId\r\n         */\r\n        public playerLastAcceptedRequestId: number;\r\n\r\n        public affectedNeighbours?: TU.RoArr<{\r\n            readonly playerId: Player.Id;\r\n            readonly newHealth: Player.Health;\r\n        }> = undefined;\r\n\r\n        public constructor(\r\n            playerId: Player.Id,\r\n            lastAcceptedRequestId: number,\r\n        ) {\r\n            this.playerId = playerId;\r\n            this.playerLastAcceptedRequestId = lastAcceptedRequestId;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * ## Player Movement Event\r\n     *\r\n     * This single method-less class carries the bare-minimum information\r\n     * needed to describe a client's request for movement to the server,\r\n     * and to broadcast an acceptance of the request describing all changes\r\n     * to the game state that must be made (or to otherwise direct-reply\r\n     * the requester in case of request-rejection).\r\n     *\r\n     * It must do so in a way that allows the server and clients to infer\r\n     * whether any message reordering occurred.\r\n     *\r\n     * ### The Problem in Summary\r\n     *\r\n     * - Client copies of the game should lag behind the master copy of\r\n     *   the game state as little as possible with as small of a choking\r\n     *   effect on a client's ability to send requests as possible. This\r\n     *   rules out doing periodic game-state-dump broadcasts (because of\r\n     *   the transmission delay), and \"big-locks\" requiring a client to\r\n     *   have a completely up-to-date copy of the game state to have its\r\n     *   requests processed.\r\n     * - Nothing should ever happen in the client copies of the game that\r\n     *   doesn't happen in the master copy at the server. Ie. Since game-\r\n     *   state-dumps are out of the question, any corruption / de-sync of\r\n     *   the client's copy of the game is considered fatal and completely\r\n     *   unrecoverable.\r\n     * - As a bonus, it would be nice to bake in a mechanism to prevent\r\n     *   malicious or unintended spam from a trigger-happy client without\r\n     *   excessively / unnecessarily throttling the request-making ability\r\n     *   or throughput of any clients.\r\n     */\r\n    export class Movement<S extends Coord.System> extends Bubble {\r\n\r\n        /**\r\n         * Any value assigned by the requester to this field should be\r\n         * ignored by the server. The server should respond with the new\r\n         * values taken on by the player for these fields.\r\n         */\r\n        public newPlayerHealth?: {\r\n            score:     Player.Health;\r\n            health: Player.Health;\r\n        } = undefined;\r\n\r\n        public readonly dest: TileModificationEvent<S>;\r\n\r\n        public tilesWithHealthUpdates?: TU.RoArr<TileModificationEvent<S>> = undefined;\r\n\r\n        public constructor(\r\n            playerId: Player.Id,\r\n            lastAcceptedRequestId: number,\r\n            destTile: Tile<S>,\r\n        ) {\r\n            super(playerId, lastAcceptedRequestId);\r\n            this.dest = {\r\n                coord:              destTile.coord,\r\n                lastKnownUpdateId:  destTile.lastKnownUpdateId,\r\n                newCharSeqPair:     undefined,\r\n                newFreeHealth:      undefined,\r\n            };\r\n        }\r\n    }\r\n\r\n}\r\nObject.freeze(PlayerActionEvent);\r\n","import { OmHooks } from \"browser/OmHooks\";\r\nimport type { Lang, Player } from \"utils/TypeDefs\";\r\n\r\nimport { Coord, Tile } from \"./Tile\";\r\n\r\nexport { Coord } from \"./Tile\";\r\n\r\n\r\n/**\r\n * Implicitly handles visuals with help from CSS.\r\n *\r\n * Layers:\r\n * 0. Invisible cell layer (opaque on visual bell)\r\n * 1. Empty layer for spotlight mask\r\n * 2. Player face layer\r\n * 3. Language Written Character\r\n * 4. Language Type-able Sequence\r\n *\r\n * https://developer.mozilla.org/en-US/docs/Web/CSS/z-index\r\n * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index\r\n * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context\r\n *\r\n * Dataset:\r\n * Top-level layer has property \"scoreValue\"\r\n *\r\n * @extends Tile\r\n */\r\nexport class VisibleTile<S extends Coord.System> extends Tile<S> {\r\n\r\n    readonly #baseElem:     HTMLElement;\r\n    private readonly langCharElem:  HTMLDivElement;\r\n    private readonly langSeqElem:   HTMLDivElement;\r\n\r\n    public constructor(coordDesc: Tile<S>[\"coord\"]) {\r\n        super(coordDesc);\r\n        {\r\n            const baseElem = document.createElement(\"div\");\r\n            baseElem.classList.add(OmHooks.Tile.Class.BASE);\r\n            this.#baseElem = baseElem;\r\n        } {\r\n            // Must be the first child. See note in CSS class hook.\r\n            const pthbElem = document.createElement(\"div\");\r\n            pthbElem.classList.add(OmHooks.Tile.Class.POINTER_HB);\r\n            this.#baseElem.appendChild(pthbElem);\r\n        } {\r\n            const charElem = document.createElement(\"div\");\r\n            charElem.classList.add(\r\n                OmHooks.Tile.Class.LANG_CHAR,\r\n                OmHooks.General.Class.FILL_PARENT,\r\n            );\r\n            this.#baseElem.appendChild(charElem);\r\n            this.langCharElem = charElem;\r\n        } {\r\n            const seqElem = document.createElement(\"div\");\r\n            seqElem.classList.add(OmHooks.Tile.Class.LANG_SEQ);\r\n            this.#baseElem.appendChild(seqElem);\r\n            this.langSeqElem = seqElem;\r\n        }\r\n    }\r\n\r\n    public __addToDom(parent: HTMLElement): void {\r\n        parent.appendChild(this.#baseElem);\r\n    }\r\n\r\n    public __setOccupant(playerId: Player.Id, playerElem: HTMLElement): void {\r\n        super.__setOccupant(playerId, playerElem);\r\n        this.#baseElem.appendChild(playerElem)\r\n    }\r\n\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public visualBell(): void {\r\n        this.#baseElem; // TODO.impl Use an animation to flash tile element?\r\n    }\r\n\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public evictOccupant(): void {\r\n        super.evictOccupant();\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public set freeHealth(newHealth: number) {\r\n        super.freeHealth = newHealth;\r\n        if (this.freeHealth) {\r\n            this.#baseElem.dataset[OmHooks.Tile.Dataset.HEALTH] = newHealth.toString();\r\n        } else {\r\n            delete this.#baseElem.dataset[OmHooks.Tile.Dataset.HEALTH];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public setLangCharSeqPair(charSeqPair: Lang.CharSeqPair): void {\r\n        super.setLangCharSeqPair(charSeqPair);\r\n        this.langCharElem.innerText = this.langChar;\r\n        this.langSeqElem.innerText  = this.langSeq;\r\n    }\r\n\r\n}\r\n// Assert that this extension's constructor has a compatible signature:\r\nVisibleTile as Tile.ClassIf<any>;\r\nObject.freeze(VisibleTile);\r\nObject.freeze(VisibleTile.prototype);\r\n","import { Lang as __Lang } from \"utils/TypeDefs\";\r\n\r\nimport { LangSeqTreeNode } from \"lang/LangSeqTreeNode\";\r\n\r\n\r\n/**\r\n * A language is a map from a collection of unique characters to\r\n * corresponding key-sequences. the key-sequences may be non-unique.\r\n * (try searching up \"Chinese riddle where each syllable is pronounced\r\n * 'shi'\"). A character may have more than one corresponding sequence,\r\n * representing alternate \"spellings\" (ways of typing it).\r\n *\r\n * In the use-case of this game, it is more helpful to think in the\r\n * reverse direction: As a map from typeable-key-sequences to sets of\r\n * corresponding unique characters (no character is mapped by multiple\r\n * key-sequences). This game does not require support for retrieving\r\n * the `Lang.Seq` corresponding to a `LangChar`.\r\n *\r\n * See the readme in [the implementations folder](./impl/readme.md)\r\n * for a guide on writing implementations of this class.\r\n */\r\nexport abstract class Lang extends __Lang {\r\n\r\n    /**\r\n     * The abstract, static object for this language.\r\n     */\r\n    public readonly static: Lang.ClassIf;\r\n\r\n    /**\r\n     * A \"reverse\" map from `LangSeq`s to `LangChar`s.\r\n     */\r\n    private readonly treeMap: LangSeqTreeNode<true>;\r\n\r\n    /**\r\n     * A list of leaf nodes in `treeMap` sorted in ascending order by\r\n     * hit-count. Entries should never be removed or added. They will\r\n     * always be sorted in ascending order of `tricklingHitCount`.\r\n     */\r\n    private readonly leafNodes: Array<LangSeqTreeNode>;\r\n\r\n    public get numLeaves(): number { return this.leafNodes.length; }\r\n\r\n\r\n\r\n    /**\r\n     * _Does not call reset._\r\n     *\r\n     * @param classIf -\r\n     * @param forwardDict - Weights are _relative_ values handled by\r\n     *      {@link LangSeqTreeNode}, which requires the provided values\r\n     *      to all be strictly positive values. They do not all need\r\n     *      to sum to a specific value such as 100.\r\n     */\r\n    protected constructor(classIf: Lang.ClassIf, forwardDict: Lang.CharSeqPair.WeightedForwardMap) {\r\n        super();\r\n        this.static = classIf;\r\n        this.treeMap = LangSeqTreeNode.CREATE_TREE_MAP(forwardDict);\r\n        this.leafNodes = this.treeMap.getLeafNodes();\r\n    }\r\n\r\n    public reset(): void {\r\n        this.treeMap.reset();\r\n    }\r\n\r\n\r\n    /**\r\n     * @returns\r\n     * A random `Lang.Char` in this `Lang` whose corresponding\r\n     * `Lang.Seq` is not a prefix of any `Lang.Seq` in `avoid`, and vice\r\n     * versa. They may share a common prefix as long as they are both\r\n     * longer in length than the shared prefix, and they are not equal\r\n     * to one another.\r\n     *\r\n     * This method is called to shuffle the `Lang.Char` / `Lang.Seq`\r\n     * pair at some Tile `A`. `avoid` should contain the `LangSeq`s\r\n     * from all Tiles reachable by a human Player occupying a Tile\r\n     * `B` from which they can also reach `A`\r\n     *\r\n     * In order for this `Lang` to satisfy these constraints, it must\r\n     * be true that the number of leaf nodes in this tree-structure must\r\n     * `avoid` argument.\r\n     *\r\n     * In this implementation, a human Player can only reach a\r\n     * Tile whose coord has an `infNorm` of `1` from\r\n     * that of the Tile they are currently occupying. That is,\r\n     * `avoid` contains `LangSeq`s from all Tiles with an `infNorm`\r\n     * <= `2` from the Tile to shuffle (not including itself).\r\n     * This means that here, the size of `avoid` is always bounded by\r\n     * `(2*2 + 1)^2 - 1 == 24`. Using the English alphabet (26 typeable-\r\n     * letters), this requirement is met by a hair.\r\n     *\r\n     * @param avoid\r\n     * A collection of `Lang.Seq`s to avoid conflicts with when choosing\r\n     * a `Lang.Char` to return.\r\n     *\r\n     * @param balancingScheme -\r\n     */\r\n    public getNonConflictingChar(\r\n        avoid: TU.RoArr<Lang.Seq>,\r\n        balancingScheme: Lang.BalancingScheme,\r\n    ): Lang.CharSeqPair {\r\n        // Wording the spec closer to this implementation: We must find\r\n        // characters from nodes that are not descendants or ancestors\r\n        // of nodes for sequences to avoid. We can be sure that none of\r\n        // the ancestors or descendants of avoid-nodes are avoid-nodes.\r\n\r\n        // Start by sorting according to the desired balancing scheme:\r\n        this.leafNodes.sort(LangSeqTreeNode.LEAF_CMP[balancingScheme]);\r\n\r\n        let nodeToHit: LangSeqTreeNode | undefined = undefined;\r\n        for (const leaf of this.leafNodes) {\r\n            // Take the next leaf node (don't remove it!), and if none of\r\n            // its parents are avoid-nodes, then, from the set of nodes\r\n            // including the leaf node and all its parents (minus the root),\r\n            // choose the node with the least actual/personal hit-count.\r\n            const upstreamNodes: Array<LangSeqTreeNode> = leaf.andNonRootParents();\r\n            for (let i = 0; i < upstreamNodes.length; i++) {\r\n                const conflictSeq: Lang.Seq | undefined = avoid.find(avoidSeq => {\r\n                    return avoidSeq.startsWith(upstreamNodes[i].sequence);\r\n                });\r\n                if (conflictSeq) {\r\n                    if (conflictSeq === upstreamNodes[i].sequence) {\r\n                        // Cannot use anything on this upstream path because\r\n                        // an avoid-node is directly inside it.\r\n                        upstreamNodes.splice(0);\r\n                    } else {\r\n                        // Found a node on an upstream path of an avoid-node.\r\n                        // Doesn't stop us from using what we've found so far.\r\n                        upstreamNodes.splice(i);\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n            if (upstreamNodes.length) {\r\n                // Found a non-conflicting upstream node.\r\n                // Find the node with the lowest personal hit-count:\r\n                upstreamNodes.sort(LangSeqTreeNode.PATH_CMP[balancingScheme]);\r\n                nodeToHit = upstreamNodes[0];\r\n                break;\r\n            }\r\n        }\r\n        if (!nodeToHit) {\r\n            // Should never reach here because there is a check in the\r\n            // constructor checking for this invariant.\r\n            throw new Error(`Invariants guaranteeing that a LangSeq can`\r\n            + `always be shuffled-in were not met.`\r\n            );\r\n        }\r\n        return nodeToHit.chooseOnePair(balancingScheme);\r\n    }\r\n\r\n    public simpleView(): object {\r\n        return Object.assign(Object.create(null), {\r\n            name: this.static.getName(),\r\n            desc: this.static.getBlurb(),\r\n            root: this.treeMap.simpleView(),\r\n        });\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\nexport namespace Lang {\r\n\r\n    /**\r\n     * Every constructor function (class literal) implementing the\r\n     * `Lang` class must implement this interface. Ie. These will be\r\n     * implemented as static methods.\r\n     */\r\n    export interface ClassIf {\r\n        getName(): Lang.Names.Value;\r\n        getBlurb(): string;\r\n        getInstance(): Lang;\r\n    };\r\n\r\n    /**\r\n     * An atomic unit in a written language that constitutes a single\r\n     * character. It is completely unique in its language, and has a\r\n     * single corresponding sequence (string) typeable on a keyboard.\r\n     */\r\n    export type Char = __Lang.Char;\r\n\r\n    /**\r\n     * A sequence of characters each matching {@link SEQ_REGEXP}\r\n     * that represent the intermediate interface between an Operator\r\n     * and a `LangChar`. The immediate interface is through the `Lang`\r\n     * implementation's {@link Lang#remapKey} method.\r\n     */\r\n    export type Seq = __Lang.Seq;\r\n\r\n    /**\r\n     * A key-value pair containing a `LangChar` and its corresponding\r\n     * `LangSeq`.\r\n     */\r\n    export type CharSeqPair = __Lang.CharSeqPair;\r\n    export namespace CharSeqPair {\r\n        /**\r\n         * A map from written characters to their corresponding typeable\r\n         * keyboard sequence and relative spawn weight.\r\n         *\r\n         * Shape that must be passed in to the static tree producer. The\r\n         * `Record` type enforces the invariant that {@link Lang.Char}s are\r\n         * unique in a {@link Lang}. \"CSP\" is short for {@link Lang.CharSeqPair}.\r\n         */\r\n        export type WeightedForwardMap = Record<Lang.Char, Readonly<{seq: Lang.Seq, weight: number,}>>;\r\n    }\r\n\r\n    export type BalancingScheme = __Lang.BalancingScheme;\r\n\r\n    export namespace Names {\r\n        export type Key   = __Lang.Names.Key;\r\n        export type Value = __Lang.Names.Value;\r\n    }\r\n\r\n}\r\nObject.freeze(Lang);\r\nObject.freeze(Lang.prototype);\r\n","import type { Coord, Tile } from \"./Tile\";\r\n\r\n\r\ntype CoordSys = Coord.System;\r\n\r\ntype Arguments<S extends CoordSys> = [ Coord.Bare<S>, ] | [];\r\n\r\n/**\r\n * A utility class to get destinations-to or sources-from a tile at\r\n * a specified coordinate. It is recommended to name the calling\r\n * variable \"tile\". A query starts with calling one of the methods\r\n * `at`, `destsFrom`, or `sourcesTo`. Optional filtering mutators\r\n * can be applied intermediately such as `unoccupied`. The query\r\n * ends with one of the getters `occupants` or `get`.\r\n *\r\n * @template S\r\n *\r\n * @template A\r\n * This allows `Source` implementations to accept a coordinate\r\n * specifier as an argument, such as is appropriate with a grid,\r\n * or to provide that information implicitly inside itself as\r\n * part of its spec, as is appropriate with a player.\r\n *\r\n */\r\nexport class TileGetter<S extends CoordSys, A extends Arguments<S>> {\r\n\r\n    public constructor(protected readonly source: TileGetter.Source<S,A>) { }\r\n\r\n    public at(...args: A): Tile<S> {\r\n        return this.source.__getTileAt(...args);\r\n    }\r\n    public destsFrom(...args: A): Query<S> {\r\n        return new Query(this.source.__getTileDestsFrom(...args));\r\n    }\r\n    public sourcesTo(...args: A): Query<S> {\r\n        return new Query(this.source.__getTileSourcesTo(...args));\r\n    }\r\n}\r\n\r\nexport namespace TileGetter {\r\n    /**\r\n     * A Tile should always be a source-to and destination-from itself.\r\n     */\r\n    export interface Source<S extends CoordSys, A extends Arguments<S> = [Coord.Bare<S>]> {\r\n        __getTileAt(...args: A): Tile<S>;\r\n        // NOTE: do we need to add an optional argument for range?\r\n        // If so, document that it must default to `1` if unspecified.\r\n        __getTileDestsFrom(...args: A): Array<Tile<S>>;\r\n        __getTileSourcesTo(...args: A): Array<Tile<S>>;\r\n    }\r\n}\r\nObject.freeze(TileGetter);\r\nObject.freeze(TileGetter.prototype);\r\n\r\n/**\r\n *\r\n */\r\nclass Query<S extends CoordSys> {\r\n\r\n    public constructor(protected contents: Array<Tile<S>>) { }\r\n\r\n    public get occupied(): Omit<Query<S>, \"unoccupied\"> {\r\n        this.contents = this.contents.filter((tile) => tile.isOccupied);\r\n        return this;\r\n    }\r\n\r\n    public get unoccupied(): Omit<Query<S>, \"occupied\"> {\r\n        this.contents = this.contents.filter((tile) => !tile.isOccupied);\r\n        return this;\r\n    }\r\n\r\n    public get get(): Array<Tile<S>> {\r\n        const retval = this.contents;\r\n        return retval;\r\n    }\r\n}\r\nObject.freeze(Query);\r\nObject.freeze(Query.prototype);\r\n","import { Player as __Player } from \"utils/TypeDefs\";\r\nimport { Game } from \"game/Game\";\r\n\r\nimport type { Coord, Tile } from \"floor/Tile\";\r\nimport type { Player } from \"./Player\";\r\nimport type { GameBase } from \"game/__gameparts/Base\";\r\n\r\nimport { PlayerStatus } from \"./PlayerStatus\";\r\nimport { TileGetter } from \"floor/TileGetter\";\r\n\r\n\r\n/**\r\n * Made to abstract all operations that change the {@link Player#hostTile}\r\n * field. Enforces / exposes the {@link PlayerSkeleton#moveTo} method as\r\n * the interface to any such operations.\r\n *\r\n * @extends __Player to intake its namespace exports.\r\n */\r\nexport abstract class PlayerSkeleton<S extends Coord.System> extends __Player<S> {\r\n\r\n    public readonly playerId: Player.Id;\r\n\r\n    /**\r\n     * The game object that this player belongs to.\r\n     */\r\n    public readonly game: GameBase<any,S>;\r\n\r\n    public readonly status: PlayerStatus<S>;\r\n\r\n    #hostTile: Tile<S>;\r\n\r\n    public readonly tile: TileGetter<S,[]>;\r\n\r\n\r\n\r\n    protected constructor(game: GameBase<any,S>, desc: Player.CtorArgs) {\r\n        super();\r\n        if (Math.trunc(desc.playerId) !== desc.playerId) {\r\n            throw new RangeError(\"Player ID's must be integer values.\");\r\n        }\r\n        this.playerId = desc.playerId;\r\n        this.game = game;\r\n        this.status = new (this.game.__playerStatusCtor)(\r\n            this as PlayerSkeleton<S> as Player<S>,\r\n            desc.noCheckGameOver,\r\n        );\r\n        this.tile = new TileGetter(new PlayerSkeleton.TileGetterSource(this));\r\n    }\r\n\r\n    /**\r\n     * Must be called _after_ the {@link Grid} has been reset.\r\n     * Does not evict itself from its current host tile (if it\r\n     * has one).\r\n     *\r\n     * @param spawnTile -\r\n     */\r\n    protected reset(spawnTile: Tile<S>): void {\r\n        this.#hostTile = spawnTile;\r\n        this.hostTile.__setOccupant(this.playerId, this.status.baseElem);\r\n    }\r\n\r\n\r\n\r\n    public get coord(): Coord<S> {\r\n        return this.hostTile.coord;\r\n    }\r\n\r\n    public get hostTile(): Tile<S> {\r\n        return this.#hostTile;\r\n    }\r\n\r\n    // TODO.design Abstract hook called when go near other player.\r\n    // what qualifies \"near\"? Need to call this in moveTo.\r\n    protected onGoBesideOtherPlayer(): void {\r\n        // Does nothing by default.\r\n    }\r\n\r\n    /**\r\n     * Evicts this `Player` from its last known position (which may be\r\n     * lagging behind the state of the master copy of the game.\r\n     *\r\n     * This must be called after all same-event changes pertaining to\r\n     * this player's fields have been enacted.\r\n     *\r\n     * @param dest -\r\n     */\r\n    public moveTo(dest: Tile<S>): void {\r\n        // Evict self from current `Tile`.\r\n        if (this.hostTile.occupantId !== this.playerId) {\r\n            if (this.game.gameType !== Game.Type.ONLINE) {\r\n                // Should never happen.\r\n                throw new Error(\"Linkage between player and occupied tile disagrees.\");\r\n            }\r\n            /* Otherwise, this corner case is guaranteed to follow the events\r\n            described in the below comment: at this `OnlineGame`, `p2` will\r\n            move off of the `Tile` currently occupied by this `Player`. */\r\n        }\r\n        else {\r\n            // Move off of current host `Tile`:\r\n            this.hostTile.evictOccupant();\r\n        }\r\n        // Occupy the destination `Tile.\r\n        if (dest.isOccupied) {\r\n            if (this.game.gameType !== Game.Type.ONLINE) {\r\n                // Should never happen because the Game Manager\r\n                // rejects requests to move onto an occupied `Tile`.\r\n                throw new Error(\"Only one player can occupy a tile at a time.\");\r\n            }\r\n            /* Otherwise, this is actually possible in a variant of the _DAS_\r\n            where another `Player` `p2` moves to `B`, I receive that update,\r\n            then `p2` makes a request to move to `C`, which the Game Manager\r\n            accepts and begins to notify my `OnlineGame` of, but between the\r\n            time that the GM accepts the request and when I receive the update,\r\n            I make a request to move to `B`, which gets accepted by the GM,\r\n            and because I might not be using websockets as my underlying\r\n            transport, I receive the update for my own request first, which\r\n            would appear to my `OnlineGame` as if I was moving onto the `Tile`\r\n            occupied by `p2`. */\r\n        }\r\n        else {\r\n            // Move to occupy the destination `Tile`:\r\n            this.#hostTile = dest;\r\n            dest.__setOccupant(this.playerId, this.status.baseElem);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nexport namespace PlayerSkeleton {\r\n\r\n    export class TileGetterSource<S extends Coord.System> implements TileGetter.Source<S,[]> {\r\n\r\n        public constructor(private readonly player: PlayerSkeleton<S>) { }\r\n\r\n        public __getTileAt(): Tile<S> {\r\n            return this.player.game.grid.tile.at(this.player.coord);\r\n        }\r\n\r\n        public __getTileDestsFrom(): Array<Tile<S>> {\r\n            return this.player.game.grid.tile.destsFrom(this.player.coord).get;\r\n        }\r\n\r\n        public __getTileSourcesTo(): Array<Tile<S>> {\r\n            return this.player.game.grid.tile.sourcesTo(this.player.coord).get;\r\n        }\r\n    }\r\n    Object.freeze(TileGetterSource);\r\n    Object.freeze(TileGetterSource.prototype);\r\n\r\n}\r\nObject.freeze(PlayerSkeleton);\r\nObject.freeze(PlayerSkeleton.prototype);\r\n","import type { Coord } from \"floor/Tile\";\r\nimport type { Player } from \"./Player\";\r\n\r\n\r\n/**\r\n *\r\n */\r\nexport class Team<S extends Coord.System> {\r\n\r\n    public readonly id: Team.Id;\r\n\r\n    public readonly members: TU.RoArr<Player<S>>;\r\n\r\n    #elimOrder: number;\r\n\r\n    public constructor(teamId: Team.Id, members: TU.RoArr<Player<S>>) {\r\n        if (members.length === 0) {\r\n            throw new Error(\"teams must have at least one member.\");\r\n        }\r\n        this.id = teamId;\r\n        this.members = members;\r\n        this.#elimOrder\r\n            = (this.members.every((member) => member.status.noCheckGameOver))\r\n            ? Team.ElimOrder.IMMORTAL\r\n            : Team.ElimOrder.STANDING;\r\n    }\r\n\r\n    public reset(): void {\r\n        if (this.elimOrder !== Team.ElimOrder.IMMORTAL) {\r\n            this.elimOrder = Team.ElimOrder.STANDING;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns\r\n     * Indicates the order (relative to other teams) in which this\r\n     * team was to have all its members downed at the same time at\r\n     * least once. Once a team is soft-eliminated, they can continue\r\n     * playing as normal, but there is no going back. The game ends\r\n     * when all teams but one have been soft-eliminated.\r\n     *\r\n     * ### Semantics\r\n     *\r\n     * A comparatively smaller value denotes having been soft-\r\n     * eliminated at an earlier point in the game. **The value zero\r\n     * denotes _not-having-been-soft-eliminated-yet_**.\r\n     */\r\n    public get elimOrder(): number {\r\n        return this.#elimOrder;\r\n    }\r\n    public set elimOrder(teamElimOrder: number) {\r\n        if (this.elimOrder === Team.ElimOrder.IMMORTAL) {\r\n            throw new Error(\"Cannot change the elimination status of an immortal team.\");\r\n        }\r\n        this.#elimOrder = teamElimOrder;\r\n    }\r\n\r\n}\r\nexport namespace Team {\r\n\r\n    export type Id = number;\r\n\r\n    export type ElimOrder = number;\r\n\r\n    // Special values:\r\n    export namespace ElimOrder {\r\n        /**\r\n         * A team starts off with such a value if all its players have\r\n         * specified that their downing should not cause a check for\r\n         * whether the game should end.\r\n         */\r\n        export const IMMORTAL = -1;\r\n\r\n        /**\r\n         * A team that is not invincible starts off with such a value.\r\n         */\r\n        export const STANDING = 0;\r\n    }\r\n\r\n}\r\nObject.freeze(Team);\r\nObject.freeze(Team.prototype);\r\n","import type { Coord } from \"floor/Tile\";\r\nimport type { Player } from \"./Player\";\r\nimport { Team } from \"game/player/Team\";\r\n\r\n\r\n/**\r\n * This abstracts acts of modification upon a player's state, allowing\r\n * extension classes to override setters to perform additional tasks\r\n * such as visually rendering updates to this state information in a\r\n * web browser, and playing sound effects.\r\n */\r\nexport class PlayerStatus<S extends Coord.System> {\r\n\r\n    protected readonly player: Player<S>; // Circular field reference.\r\n    public readonly noCheckGameOver: boolean;\r\n    #score:  Player.Health;\r\n    #health: Player.Health;\r\n\r\n    public readonly baseElem?: HTMLDivElement;\r\n\r\n    public constructor(player: Player<S>, noCheckGameOver: boolean) {\r\n        this.player = player;\r\n        this.noCheckGameOver = noCheckGameOver;\r\n    }\r\n\r\n    public reset(): void {\r\n        this.score   = 0;\r\n        this.health  = 0;\r\n    }\r\n\r\n\r\n    public get score(): Player.Health {\r\n        return this.#score;\r\n    }\r\n    public set score(newValue: Player.Health) {\r\n        this.#score = newValue;\r\n    }\r\n\r\n    public get health(): Player.Health {\r\n        return this.#health;\r\n    }\r\n    public set health(newHealth: Player.Health) {\r\n        const oldIsDowned = this.isDowned;\r\n        this.#health = newHealth;\r\n\r\n        if (oldIsDowned) return;\r\n        const team  = this.player.team;\r\n        const teams = this.player.game.teams;\r\n        if (this.isDowned && !(this.noCheckGameOver) && team.elimOrder === 0) {\r\n            // Right before this downing event, the team has not been\r\n            // soft-eliminated yet, but it might be now. Check it:\r\n            if (team.members.every((player) => {\r\n                return player.status.noCheckGameOver || player.status.isDowned;\r\n            })) {\r\n                // All players are downed! The team is now eliminated:\r\n                const numNonStandingTeams\r\n                    = 1 + teams.filter((team) => {\r\n                    return team.elimOrder !== Team.ElimOrder.STANDING;\r\n                }).length;\r\n                team.elimOrder\r\n                    = 1 + teams.filter((team) => {\r\n                    return team.elimOrder !== Team.ElimOrder.STANDING\r\n                        && team.elimOrder !== Team.ElimOrder.IMMORTAL;\r\n                }).length;\r\n                // Now that a team is newly-eliminated, check if the\r\n                // game should end:\r\n                if (numNonStandingTeams === teams.length) {\r\n                    this.player.game.statusBecomeOver();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // TODO.design Equation and architecture for getting/setting adjusted health.\r\n    // This should be a getter here. Easy now that I added the circular reference to the Player.\r\n\r\n    public get isDowned(): boolean {\r\n        return this.health < 0.0;\r\n    }\r\n}\r\nObject.freeze(PlayerStatus);\r\nObject.freeze(PlayerStatus.prototype);\r\n","import { Game } from \"game/Game\";\r\n\r\nimport type { Lang } from \"lang/Lang\";\r\nimport type { Coord, Tile } from \"floor/Tile\";\r\nimport type { Player as __Player } from \"utils/TypeDefs\";\r\nimport type { GameBase } from \"game/__gameparts/Base\";\r\n\r\nimport { PlayerActionEvent } from \"game/events/PlayerActionEvent\";\r\nimport { PlayerSkeleton } from \"./PlayerSkeleton\";\r\nimport { PlayerStatus } from \"./PlayerStatus\";\r\nimport { Team } from \"./Team\";\r\n\r\nexport { PlayerSkeleton };\r\nexport { PlayerStatus };\r\nexport { Team };\r\n\r\n\r\n/**\r\n *\r\n */\r\nexport class Player<S extends Coord.System> extends PlayerSkeleton<S> {\r\n\r\n    public readonly familyId: Player.Family;\r\n\r\n    public readonly teamId: Team.Id;\r\n\r\n    public readonly username: Player.Username;\r\n\r\n    public lastAcceptedRequestId: number;\r\n\r\n    public requestInFlight: boolean;\r\n\r\n\r\n    public constructor(game: GameBase<any,S>, desc: Readonly<Player.CtorArgs>) {\r\n        super(game, desc);\r\n\r\n        if (!(Player.Username.REGEXP.test(desc.username))) {\r\n            throw new RangeError(`Username \\\"${desc.username}\\\"`\r\n            + ` does not match the required regular expression,`\r\n            + ` \\\"${Player.Username.REGEXP.source}\\\".`\r\n            );\r\n        }\r\n        this.familyId = desc.familyId;\r\n        this.teamId   = desc.teamId;\r\n        this.username = desc.username;\r\n    }\r\n\r\n    public reset(spawnTile: Tile<S>): void {\r\n        super.reset(spawnTile);\r\n        this.status.reset();\r\n        this.lastAcceptedRequestId = PlayerActionEvent.INITIAL_REQUEST_ID;\r\n        this.requestInFlight = false;\r\n    }\r\n\r\n    public __abstractNotifyThatGameStatusBecamePlaying(): void {}\r\n    public __abstractNotifyThatGameStatusBecamePaused():  void {}\r\n    public __abstractNotifyThatGameStatusBecameOver():    void {}\r\n\r\n\r\n    /**\r\n     * Called automatically by {@link OperatorPlayer#seqBufferAcceptKey}\r\n     * for {@link OperatorPlayer}s, and by a periodic callback for\r\n     * {@link ArtificialPlayer}s. Handles behaviour common between all\r\n     * implementations.\r\n     *\r\n     * @final\r\n     * @param dest -\r\n     * @throws Error if the game is over or paused.\r\n     */\r\n    protected makeMovementRequest(dest:Tile<S>): void {\r\n        if (this.game.status !== Game.Status.PLAYING) {\r\n            throw new Error(\"This is not a necessary precondition, but we're doing it anyway.\");\r\n        } else if (this.requestInFlight) {\r\n            throw new Error(\"Only one request should ever be in flight at a time.\");\r\n        }\r\n        this.requestInFlight = true;\r\n        this.game.processMoveRequest(\r\n            new PlayerActionEvent.Movement(\r\n                this.playerId,\r\n                this.lastAcceptedRequestId,\r\n                dest,\r\n            ),\r\n        );\r\n    }\r\n\r\n    public get team(): Team<S> {\r\n        return this.game.teams[this.teamId];\r\n    }\r\n\r\n    public isTeamedWith(other: Player<S>): boolean {\r\n        return this.team.members.includes(other);\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\nexport namespace Player {\r\n\r\n    export type Family = __Player.Family;\r\n\r\n    export type Id = __Player.Id;\r\n\r\n    export type SocketId = string;\r\n\r\n    /**\r\n     * Health be picked up from the floor where it is randomly spawned\r\n     * by the game manager. It can be used to attack enemy players, or\r\n     * to heal teammates.\r\n     */\r\n    export type Health = __Player.Health;\r\n\r\n    export type Username = string;\r\n\r\n    export namespace Username {\r\n        /**\r\n         * The choice of this is somewhat arbitrary. This should be enforced\r\n         * externally since player descriptors are passed to the constructor.\r\n         *\r\n         * Requirements:\r\n         * - Starts with a letter.\r\n         * - No whitespace except for non-consecutive space characters.\r\n         * - Must contain at least five non-space characters that are\r\n         *      either letters, numbers, or the dash character.\r\n         */\r\n        export const REGEXP = /[a-zA-Z](?:[ ]?[a-zA-Z0-9:-]+?){4,}/;\r\n    }\r\n\r\n    /**\r\n     * # Player Constructor Arguments\r\n     */\r\n    export type CtorArgs = CtorArgs.PreIdAssignment & Readonly<{\r\n        playerId: Player.Id;\r\n        langName: Lang.Names.Value[\"id\"],\r\n    }>;\r\n\r\n    export namespace CtorArgs {\r\n\r\n        export type PreIdAssignment = Readonly<{\r\n            /**\r\n             * This determines which constructor function to use.\r\n             */\r\n            familyId: Player.Family;\r\n            teamId:   Team.Id;\r\n            socketId: SocketId | undefined; // Must exist for operated players.\r\n            username: Username;\r\n            noCheckGameOver: boolean;\r\n        }>;\r\n\r\n        /**\r\n         * @returns\r\n         * Squashes teamId fields to be suitable for array indices.\r\n         *\r\n         * @param playerDescs -\r\n         * @param langName -\r\n         */\r\n        export const finalize = (\r\n            playerDescs: TU.RoArr<CtorArgs.PreIdAssignment>,\r\n            langName: Lang.Names.Value[\"id\"],\r\n        ): TU.RoArr<CtorArgs> => {\r\n            // Map team ID's to consecutive numbers\r\n            // (to play nice with array representations):\r\n            const teamIdCleaner: TU.RoArr<Team.Id>\r\n                = Array.from(new Set(playerDescs.map((player) => player.teamId)))\r\n                .sort((a, b) => a - b)\r\n                .reduce((prev, originalId, squashedId) => {\r\n                    prev[originalId] = squashedId;\r\n                    return prev;\r\n                }, [] as Array<Team.Id>);\r\n            return (playerDescs as Array<CtorArgs.PreIdAssignment>)\r\n            .sort((pda, pdb) => teamIdCleaner[pda.teamId] - teamIdCleaner[pdb.teamId])\r\n            .map<CtorArgs>((playerDesc, index) => { return {\r\n                playerId:   index,\r\n                familyId:   playerDesc.familyId,\r\n                teamId:     teamIdCleaner[playerDesc.teamId],\r\n                socketId:   playerDesc.socketId,\r\n                username:   playerDesc.username,\r\n                langName:   langName,\r\n                noCheckGameOver: playerDesc.noCheckGameOver,\r\n            }; });\r\n        };\r\n\r\n    }\r\n    Object.freeze(CtorArgs);\r\n\r\n}\r\nObject.freeze(Player);\r\nObject.freeze(Player.prototype);\r\n","import { Game } from \"game/Game\";\r\nimport type { Coord, Tile } from \"floor/Tile\";\r\nimport type { GameManager } from \"game/__gameparts/Manager\";\r\n\r\nimport { Player } from \"./Player\";\r\n\r\n\r\n/**\r\n * Unlike {@link HumanPlayer}s, these are not guided by human input.\r\n * Instead, they are essentially defined by how often they move, and\r\n * where they decide to move toward each time they move.\r\n *\r\n * Can be paused and un-paused by the Game Manager.\r\n *\r\n * @extends Player\r\n */\r\nexport abstract class ArtificialPlayer<S extends Coord.System> extends Player<S> {\r\n\r\n    declare public readonly game: GameManager<any,S>;\r\n\r\n    private scheduledMovementCallbackId: number | NodeJS.Timeout;\r\n\r\n    /**\r\n     * See {@link ArtificialPlayer.of} for the public constructor\r\n     * interface.\r\n     *\r\n     * @param game -\r\n     * @param desc -\r\n     */\r\n    protected constructor(game: GameManager<any,S>, desc: Player.CtorArgs) {\r\n        super(game, desc);\r\n        if (game.gameType === Game.Type.ONLINE) {\r\n            throw new TypeError(\"OnlineGames should be using regular Players instead.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a {@link Pos} representing an absolute coordinate (ie.\r\n     * one that is relative to the {@link Game}'s origin position')\r\n     * that this `ArtificialPlayer` intends to move toward in its next\r\n     * movement request. Pos may contain non-integer coordinate values,\r\n     * and it does not have to be inside the bounds of the {@link Grid}.\r\n     */\r\n    protected abstract computeDesiredDestination(): Coord<S>;\r\n\r\n    /**\r\n     * Units are in milliseconds.\r\n     */\r\n    protected abstract computeNextMovementTimer(): number;\r\n\r\n    public __abstractNotifyThatGameStatusBecamePlaying(): void {\r\n        this.movementContinueWithInitialDelay();\r\n    }\r\n    public __abstractNotifyThatGameStatusBecamePaused(): void {\r\n        this.game.cancelTimeout(this.scheduledMovementCallbackId);\r\n        this.scheduledMovementCallbackId = undefined!;\r\n    }\r\n    public __abstractNotifyThatGameStatusBecameOver(): void {\r\n        this.game.cancelTimeout(this.scheduledMovementCallbackId);\r\n        this.scheduledMovementCallbackId = undefined!;\r\n    }\r\n\r\n    private movementContinue(): void {\r\n        this.makeMovementRequest(this.game.grid.getUntToward(\r\n            this.coord, this.computeDesiredDestination()\r\n        ));\r\n        this.movementContinueWithInitialDelay();\r\n    }\r\n\r\n    private movementContinueWithInitialDelay(): void {\r\n        // Schedule the next movement.\r\n        this.scheduledMovementCallbackId = this.game.setTimeout(\r\n            this.movementContinue,\r\n            this.computeNextMovementTimer(),\r\n            // * Callback function arguments go here.\r\n        );\r\n        return;\r\n    }\r\n}\r\n\r\n\r\nexport namespace ArtificialPlayer {\r\n\r\n    export declare const __Constructors: Readonly<Record<\r\n        Exclude<Player.Family, typeof Player.Family.HUMAN>,\r\n        typeof ArtificialPlayer\r\n    >>;\r\n\r\n    export const of = <S extends Coord.System>(\r\n        game: Readonly<GameManager<any,S>>,\r\n        playerDesc: Readonly<Player.CtorArgs>,\r\n    ): ArtificialPlayer<S> => {\r\n        return new (__Constructors[playerDesc.familyId])(game, playerDesc);\r\n    };\r\n}\r\n// ArtificialPlayer gets frozen in PostInit after __Constructors get initialized.\r\n","import { Lang } from \"lang/Lang\";\r\n\r\n\r\n/**\r\n *\r\n */\r\nexport namespace English {\r\n\r\n    /**\r\n     * # Lowercase (QWERTY)\r\n     *\r\n     * https://wikipedia.org/wiki/Keyboard_layout#QWERTY\r\n     */\r\n    export class Lowercase extends Lang {\r\n\r\n        private static SINGLETON?: Lowercase = undefined;\r\n\r\n        public static getName(): Lang.Names.Value {\r\n            return Lang.Names.ENGLISH__LOWERCASE;\r\n        }\r\n\r\n        public static getBlurb(): string {\r\n            return \"\"; // TODO.doc\r\n        }\r\n\r\n        public static getInstance(): Lowercase {\r\n            if (!this.SINGLETON) {\r\n                this.SINGLETON  = new Lowercase();\r\n            }\r\n            return this.SINGLETON;\r\n        }\r\n\r\n        // TODO.learn see https://wikipedia.org/wiki/Keyboard_layout#Dvorak\r\n        // and https://wikipedia.org/wiki/Keyboard_layout#Colemak\r\n\r\n        private constructor() { super(\r\n            Lowercase,\r\n            Object.entries(LETTER_FREQUENCY).reduce<Lang.CharSeqPair.WeightedForwardMap>(\r\n                (accumulator, current) => {\r\n                    const char: Lang.Char = current[0];\r\n                    const seq:  Lang.Seq  = current[0];\r\n                    const weight: number  = current[1];\r\n                    accumulator[char] = { seq, weight, };\r\n                    return accumulator;\r\n                },\r\n                {},\r\n            ),\r\n        ); }\r\n    }\r\n    Lowercase as Lang.ClassIf;\r\n    Object.seal(Lowercase);\r\n    Object.freeze(Lowercase.prototype);\r\n\r\n\r\n    /**\r\n     * # Mixed-Case (QWERTY)\r\n     *\r\n     * https://wikipedia.org/wiki/Keyboard_layout#QWERTY\r\n     */\r\n    export class MixedCase extends Lang {\r\n\r\n        private static SINGLETON?: MixedCase = undefined;\r\n\r\n        public static getName(): Lang.Names.Value {\r\n            return Lang.Names.ENGLISH__MIXEDCASE;\r\n        }\r\n\r\n        public static getBlurb(): string {\r\n            return \"\"; // TODO.doc\r\n        }\r\n\r\n        public static getInstance(): MixedCase {\r\n            if (!this.SINGLETON) {\r\n                this.SINGLETON  = new MixedCase();\r\n            }\r\n            return this.SINGLETON;\r\n        }\r\n\r\n        private constructor() {\r\n            let initializer: Lang.CharSeqPair.WeightedForwardMap = {};\r\n            const addMappings = (charSeqTransform: (charOrSeq: string) => string): void => {\r\n                initializer = Object.entries(LETTER_FREQUENCY).reduce(\r\n                    (accumulator, current) => {\r\n                        const char: Lang.Char = charSeqTransform(current[0]);\r\n                        const seq:  Lang.Seq  = charSeqTransform(current[0]);\r\n                        const weight: number  = current[1];\r\n                        accumulator[char] = { seq, weight, };\r\n                        return accumulator;\r\n                    },\r\n                    initializer,\r\n                );\r\n            };\r\n            addMappings((cs) => cs.toLowerCase());\r\n            addMappings((cs) => cs.toUpperCase());\r\n            super(\r\n                MixedCase,\r\n                initializer,\r\n            );\r\n        }\r\n    }\r\n    MixedCase as Lang.ClassIf;\r\n    Object.seal(MixedCase);\r\n    Object.freeze(MixedCase.prototype);\r\n\r\n\r\n    /**\r\n     * Values obtained from https://wikipedia.org/wiki/Letter_frequency\r\n     */\r\n    const LETTER_FREQUENCY = Object.freeze(<const>{\r\n        a: 8.167, b: 1.492, c: 2.202, d: 4.253,\r\n        e:12.702, f: 2.228, g: 2.015, h: 6.094,\r\n        i: 6.966, j: 0.153, k: 1.292, l: 4.025,\r\n        m: 2.406, n: 6.749, o: 7.507, p: 1.929,\r\n        q: 0.095, r: 5.987, s: 6.327, t: 9.356,\r\n        u: 2.758, v: 0.978, w: 2.560, x: 0.150,\r\n        y: 1.994, z: 0.077,\r\n    });\r\n\r\n}\r\nObject.seal(English);\r\n","import { Lang } from \"lang/Lang\";\r\nimport { Game } from \"game/Game\";\r\n\r\nimport type { Coord, Tile } from \"floor/Tile\";\r\nimport type { VisibleTile } from \"floor/VisibleTile\";\r\nimport type { VisiblePlayerStatus } from \"./VisiblePlayerStatus\";\r\nimport type { GameBase } from \"game/__gameparts/Base\";\r\n\r\nimport { Player } from \"./Player\";\r\n\r\n\r\n/**\r\n *\r\n * @extends Player\r\n */\r\nexport class OperatorPlayer<S extends Coord.System> extends Player<S> {\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    declare public readonly game: GameBase<(Game.Type.OFFLINE|Game.Type.ONLINE),S>;\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    declare public readonly hostTile: VisibleTile<S>;\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    declare public readonly status: VisiblePlayerStatus<S>;\r\n\r\n    /**\r\n     * Invariant: always matches the prefix of the {@link LangSeq} of\r\n     * an unoccupied neighbouring {@link Tile}.\r\n     */\r\n    #seqBuffer: Lang.Seq;\r\n\r\n    private readonly langRemappingFunc: {(input: string): string};\r\n\r\n\r\n    public constructor(game: GameBase<any,S>, desc: Readonly<Player.CtorArgs>) {\r\n        super(game, desc);\r\n        this.langRemappingFunc = Lang.RemappingFunctions[desc.langName];\r\n    }\r\n\r\n    /**\r\n     * @override {@link Player#reset}\r\n     */\r\n    public reset(spawnTile: Tile<S>): void {\r\n        super.reset(spawnTile);\r\n        this.#seqBuffer = \"\";\r\n    }\r\n\r\n\r\n    /**\r\n     * Callback function invoked when the Operator presses a key while\r\n     * the game's html element has focus. Because of how JavaScript\r\n     * and also Node.js run in a single thread, this is an atomic\r\n     * operation (implementation must not intermediately schedule any\r\n     * other task-relevant callbacks until all critical operations are\r\n     * complete).\r\n     *\r\n     * @param event - The object describing the `KeyboardEvent`.\r\n     */\r\n    public processKeyboardInput(event: KeyboardEvent): void {\r\n        if (false) {\r\n\r\n        // @ Above: Conditional handlers for actions that are valid\r\n        // even when the game is over or paused.\r\n        // ==========================================================\r\n        } else if (this.game.status === Game.Status.PLAYING) {\r\n            if (!this.requestInFlight) {\r\n                // Only process movement-type input if the last request got\r\n                // acknowledged by the Game Manager and the game is playing.\r\n                // TODO.design is this okay? will any languages require different behaviour?\r\n                if (event.key.length !== 1) return;\r\n                this.seqBufferAcceptKey(event.key);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Automatically makes a call to make a movement request if the\r\n     * provided `key` completes the `LangSeq` of a UNT. Does not do\r\n     * any checking regarding {@link OperatorPlayer#requestInFlight}.\r\n     *\r\n     * @param key\r\n     * The pressed typeable key as a string. Pass an empty string to\r\n     * trigger a refresh of the {@link OperatorPlayer#_seqBuffer} to\r\n     * maintain its invariant.\r\n     */\r\n    public seqBufferAcceptKey(key: string | undefined): void {\r\n        const unts = this.tile.destsFrom().unoccupied.get;\r\n        if (unts.length === 0) {\r\n            // Every neighbouring `Tile` is occupied!\r\n            // In this case, no movement is possible.\r\n            return;\r\n        }\r\n        if (key) {\r\n            key = this.langRemappingFunc(key);\r\n            if (!(Lang.Seq.REGEXP.test(key))) {\r\n                // throw new RangeError(`The implementation of input transformation`\r\n                // + ` in the currently selected language did not follow the rule`\r\n                // + ` of producing output matching the regular expression`\r\n                // + ` \\\"${Lang.Seq.REGEXP.source}\\\".`\r\n                // );\r\n                return;\r\n            }\r\n        } else {\r\n            const possibleTarget = unts.find((tile) => tile.langSeq.startsWith(this.seqBuffer));\r\n            if (!possibleTarget) {\r\n                // If the thing I was trying to get to is gone, clear the buffer.\r\n                this.#seqBuffer = \"\";\r\n            }\r\n            return;\r\n        }\r\n\r\n        for ( // loop through substring start offset of newSeqBuffer:\r\n            let newSeqBuffer: Lang.Seq = this.seqBuffer + key;\r\n            newSeqBuffer.length;\r\n            newSeqBuffer = newSeqBuffer.substring(1)\r\n        ) {\r\n            // look for the longest suffixing substring of `newSeqBuffer`\r\n            // that is a prefixing substring of any UNT's.\r\n            const possibleTarget = unts.find((tile) => tile.langSeq.startsWith(newSeqBuffer));\r\n            if (possibleTarget) {\r\n                this.#seqBuffer = newSeqBuffer;\r\n                if (possibleTarget.langSeq === newSeqBuffer) {\r\n                    this.makeMovementRequest(possibleTarget);\r\n                }\r\n                return;\r\n            }\r\n        }\r\n        // Operator's new `seqBuffer` didn't match anything.\r\n        this.#seqBuffer = \"\";\r\n        this.hostTile.visualBell();\r\n    }\r\n\r\n    /**\r\n     * Automatically clears the {@link OperatorPlayer#seqBuffer}.\r\n     *\r\n     * @override\r\n     */\r\n    public moveTo(dest: Tile<S>): void {\r\n        // Clear my `seqBuffer` first:\r\n        this.#seqBuffer = \"\";\r\n        super.moveTo(dest);\r\n    }\r\n\r\n\r\n    public get seqBuffer(): Lang.Seq {\r\n        return this.#seqBuffer;\r\n    }\r\n\r\n}\r\nObject.freeze(OperatorPlayer);\r\nObject.freeze(OperatorPlayer.prototype);\r\n","import { OmHooks } from \"browser/OmHooks\";\r\nimport type { Coord } from \"floor/Tile\";\r\nimport type { Player } from \"./Player\";\r\nimport { OperatorPlayer } from \"./OperatorPlayer\";\r\nimport { PlayerStatus } from \"./PlayerStatus\";\r\nimport { Team } from \"game/player/Team\";\r\n\r\n\r\n// TODO.impl make the overridden setters modify the HTML elements to\r\n// visually indicate the changes.\r\nexport class VisiblePlayerStatus<S extends Coord.System> extends PlayerStatus<S> {\r\n\r\n    declare public readonly baseElem: HTMLDivElement;\r\n\r\n\r\n    public constructor(player: Player<S>, noCheckGameOver: boolean) {\r\n        super(player, noCheckGameOver);\r\n        {\r\n            const baseElem = document.createElement(\"div\");\r\n            baseElem.classList.add(\r\n                OmHooks.Player.Class.BASE,\r\n                OmHooks.General.Class.FILL_PARENT,\r\n            );\r\n            this.baseElem = baseElem;\r\n        } {\r\n            if (this.player instanceof OperatorPlayer) {\r\n                const spotlightElem = document.createElement(\"div\");\r\n                spotlightElem.classList.add(\r\n                    OmHooks.Grid.Class.SPOTLIGHT,\r\n                );\r\n                this.baseElem.appendChild(spotlightElem);\r\n            }\r\n        } {\r\n            // Setup downedOverlay element:\r\n            const dOverlayElem = document.createElement(\"div\");\r\n            dOverlayElem.classList.add(\r\n                OmHooks.Player.Class.DOWNED_OVERLAY,\r\n                OmHooks.General.Class.FILL_PARENT,\r\n            );\r\n            this.baseElem.appendChild(dOverlayElem);\r\n        }\r\n    }\r\n\r\n\r\n    public set score(newValue: Player.Health) {\r\n        super.score = newValue;\r\n    }\r\n\r\n    public set health(newHealth: Player.Health) {\r\n        const oldIsDowned = this.isDowned;\r\n        super.health = newHealth;\r\n\r\n        if (oldIsDowned !== this.isDowned) {\r\n            // CSS integration for Player.isDowned rendering.\r\n            const dataDowned = OmHooks.Player.Dataset.DOWNED;\r\n            if (this.isDowned) {\r\n                if (this.player.team.elimOrder) {\r\n                    this.baseElem.dataset[dataDowned] = \"team\";\r\n                } else {\r\n                    this.baseElem.dataset[dataDowned] = \"self\";\r\n                }\r\n            } else {this.baseElem.dataset[dataDowned] = \"no\"; }\r\n        }\r\n    }\r\n\r\n}\r\nexport namespace VisiblePlayerStatus {\r\n    /**\r\n     * This must be called once after all teams are constructed.\r\n     * @param teams -\r\n     * @param operator\r\n     * A reference to the operator player. Used to determine colouring.\r\n     */\r\n    export function colourizeTeamMembers<S extends Coord.System>(\r\n        teams: TU.RoArr<Team<S>>,\r\n        operator: OperatorPlayer<S>,\r\n    ): void {\r\n        for (const team of teams) {\r\n            for (const member of team.members) {\r\n                (member.status as VisiblePlayerStatus<S>)\r\n                .baseElem.dataset[OmHooks.Player.Dataset.FACE_SWATCH]\r\n                = (member === operator) ? \"me\"\r\n                : (member.teamId === operator.teamId) ? \"teammate\" : \"opponent\";\r\n            }\r\n        }\r\n    }\r\n}\r\nObject.freeze(VisiblePlayerStatus);\r\nObject.freeze(VisiblePlayerStatus.prototype);\r\n","import type { Lang, Player } from \"utils/TypeDefs\";\r\nimport { OmHooks } from \"browser/OmHooks\";\r\nimport { Coord, Tile } from \"./Tile\";\r\nimport { TileGetter } from \"./TileGetter\";\r\n\r\nimport type { Euclid2 } from \"./impl/Euclid2\";\r\nimport type { Beehive } from \"./impl/Beehive\";\r\nimport { VisibleGrid } from \"floor/VisibleGrid\";\r\n\r\n\r\n/**\r\n * #  The Grid Class\r\n *\r\n * A Collection of Tiles.\r\n */\r\nexport abstract class Grid<S extends Coord.System> implements TileGetter.Source<S> {\r\n\r\n    // A type-annotated alias to this.constructor.\r\n    public readonly static: Grid.ClassIf<S>;\r\n\r\n    public readonly dimensions: Grid.Dimensions<S>;\r\n\r\n    public get area(): number {\r\n        return this.static.getArea(this.dimensions);\r\n    }\r\n\r\n    public readonly tile: TileGetter<S,[Coord.Bare<S>]>;\r\n\r\n\r\n    /**\r\n     * Protected. See `Grid.getImplementation` for how to access class\r\n     * literals for construction.\r\n     *\r\n     * _Does not call reset._\r\n     *\r\n     * @param desc -\r\n     */\r\n    protected constructor(desc: Grid.CtorArgs<S>) {\r\n        this.static = desc.gridClass;\r\n        this.dimensions = desc.dimensions;\r\n        this.tile = new TileGetter(this);\r\n    }\r\n\r\n    /**\r\n     * Calls {@link Tile#reset} for each {@link Tile} in this `Grid`.\r\n     */\r\n    public reset(): void {\r\n        this.forEachTile((tile) => tile.reset());\r\n    }\r\n\r\n    /**\r\n     * Performs simple checks that the grid is playable.\r\n     *\r\n     * - Each tile in the grid has a non-self destination (coord#equals).\r\n     * - (compute-heavyish): Each tile follows Impl.getAmbiguityThreshold\r\n     */\r\n    protected check(): void {\r\n        // Check that\r\n    }\r\n\r\n\r\n    /**\r\n     * For BaseGame's implementation of SER/DES to work, the traversal\r\n     * order taken by an implementation of this method must depend\r\n     * only on the dimensions of the instance. Ie. If two Grids (such\r\n     * as those at the Client and Server when separated by a network)\r\n     * were constructed with the same arguments for their dimensions,\r\n     * then their Tiles should be traversed in the same order by this\r\n     * function.\r\n     *\r\n     * @param consumer -\r\n     * @param thisArg -\r\n     */\r\n    public abstract forEachTile(consumer: (tile: Tile<S>) => void, thisArg?: object): void;\r\n\r\n    /**\r\n     * @returns\r\n     * One of the closest unoccupied neighbouring tiles toward the\r\n     * direction of `intendedDest`. When possible, ties are encouraged\r\n     * to be broken in such a way that imitates movement in a straight\r\n     * path (visually speaking).\r\n     *\r\n     * **Important:** The caller must first break the upward occupancy\r\n     * link by calling `this.hostTile.evictOccupant();` This is so that\r\n     * the current position of this `ArtificialPlayer` will always be\r\n     * an option when everything adjacent to it is occupied.\r\n     *\r\n     * @param sourceCoord\r\n     * The coordinate from which to find the next hop.\r\n     *\r\n     * @param intendedDest\r\n     * Does not need to be within the boundaries of the {@link Game}'s\r\n     * grid, or have integer-valued coordinate values.\r\n     */\r\n   public abstract getUntToward(sourceCoord: Coord<S>, intendedDest: Coord<S>): Tile<S>;\r\n\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public abstract __getTileAt(coord: Coord.Bare<S>): Tile<S>;\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public abstract __getTileDestsFrom(coord: Coord.Bare<S>): Array<Tile<S>>;\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public abstract __getTileSourcesTo(coord: Coord.Bare<S>): Array<Tile<S>>;\r\n\r\n    /**\r\n     * Note: I would rather have this implementation go under the\r\n     * `VisibleGrid` class, but I don't want to get into mixins as of\r\n     * now to get around no-multiple-inheritance.\r\n     *\r\n     * @param desc -\r\n     * @param gridImplElem -\r\n     */\r\n    public __VisibleGrid_super(desc: Grid.CtorArgs<S>, gridImplElem: HTMLElement): void {\r\n        const OHG = OmHooks.Grid;\r\n        gridImplElem.classList.add(OHG.Class.IMPL_BODY);\r\n        const parentElem = document.getElementById(desc.domParentHtmlIdHook);\r\n        if (!parentElem) {\r\n            throw new RangeError(`The ID \\\"${desc.domParentHtmlIdHook}\\\"`\r\n            + ` did not refer to an existing html element.`);\r\n        }\r\n        parentElem.dataset[OHG.Dataset.COORD_SYS] = desc.coordSys;\r\n        parentElem.classList.add(\r\n            OHG.Class.GRID,\r\n            OmHooks.General.Class.TEXT_SELECT_DISABLED,\r\n        );\r\n        // Remove all child elements from host and then append the new grid:\r\n        parentElem.querySelectorAll(`.${OHG.Class.IMPL_BODY}`).forEach((node) => node.remove());\r\n        parentElem.appendChild(gridImplElem);\r\n        gridImplElem.tabIndex = 0;\r\n        (this as TU.NoRo<Grid<S>> as TU.NoRo<VisibleGrid<S>>).baseElem = gridImplElem;\r\n        {\r\n            // Add a \"keyboard-disconnected\" icon if not added already:\r\n            // This needs to be a _later_ sibling of gridImplElem.\r\n            let kbdDcIcon: HTMLElement | null = parentElem\r\n                .querySelector(`:scope > .${OHG.Class.KBD_DC_ICON}`);\r\n            if (!kbdDcIcon) {\r\n                // TODO.impl Add an <svg> with icon instead please.\r\n                kbdDcIcon = document.createElement(\"div\");\r\n                kbdDcIcon.classList.add(OHG.Class.KBD_DC_ICON);\r\n                kbdDcIcon.innerText = \"(click grid to continue typing)\";\r\n                parentElem.appendChild(kbdDcIcon);\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\nexport namespace Grid {\r\n\r\n    /**\r\n     * Values do not _need_ to be in range or integers.\r\n     */\r\n    export type Dimensions<S extends Coord.System>\r\n        = S extends Coord.System.EUCLID2 ? Euclid2.Grid.Dimensions\r\n        : S extends Coord.System.BEEHIVE ? Beehive.Grid.Dimensions\r\n        : never;\r\n\r\n    // ==============================================================\r\n    // Note: The below exports do not require any modifications with\r\n    // the additions of new coordinate systems.\r\n    // ==============================================================\r\n\r\n    export type CtorArgs<S extends Coord.System> = {\r\n        gridClass: Grid.ClassIf<S>;\r\n        tileClass: Tile.ClassIf<S>;\r\n        coordSys: S;\r\n        dimensions: Dimensions<S>;\r\n        domParentHtmlIdHook: string;\r\n    };\r\n\r\n    /**\r\n     * Used to simulate abstract static methods.\r\n     */\r\n    export interface ClassIf<S extends Coord.System> {\r\n\r\n        /**\r\n         * Constructor\r\n         */\r\n        new(desc: CtorArgs<S>): Grid<S>;\r\n\r\n        /**\r\n         * @returns\r\n         * From the caller's point of view, the ambiguity floor is the\r\n         * minimum number of leaf nodes a language must have to be\r\n         * playable with this coordinate system's grid.\r\n         *\r\n         * From the specification's point of view, it is the promised\r\n         * maximum size- for any tile in the grid- of the set of all\r\n         * destinations from sources to itself, excluding itself.\r\n         */\r\n        // TODO.test write a test that checks that this holds for each implementation?\r\n        getAmbiguityThreshold(): number;\r\n\r\n        /**\r\n         * @see Grid.DimensionBounds\r\n         */\r\n        getSizeLimits(): Grid.DimensionBounds<S>;\r\n\r\n        /**\r\n         * @returns\r\n         * The number of Tiles that could fit in a Grid of such bounds.\r\n         *\r\n         * @param bounds -\r\n         */\r\n        getArea(bounds: Dimensions<S>): number;\r\n\r\n        /**\r\n         * @returns\r\n         * A coordinate with random, integer-valued fields within the\r\n         * specified upper limits\r\n         *\r\n         * @param boundX An exclusive bound on x-coordinate.\r\n         * @param boundY An exclusive bound on y-coordinate. Optional. Defaults to `boundX`.\r\n         */\r\n        getRandomCoord(bounds: Dimensions<S>): Coord<S>;\r\n\r\n        /**\r\n         * Return values do not need to be the same for repeated calls\r\n         * with identical arguments. None of the returned coordinates\r\n         * should be the same.\r\n         *\r\n         * @param playerCounts -\r\n         */\r\n        getSpawnCoords(\r\n            playerCounts: number,\r\n            dimensions: Dimensions<S>,\r\n        ): TU.RoArr<Coord.Bare<S>>;\r\n\r\n    };\r\n\r\n    // Each implementation must register itself into this dictionary.\r\n    export declare const __Constructors: {\r\n        readonly [ S in Coord.System ]: Grid.ClassIf<S>\r\n    };\r\n\r\n    /**\r\n     * @returns\r\n     * A Grid class for the specified coordinate system.\r\n     *\r\n     * @param coordSys -\r\n     */\r\n    export const getImplementation = <S extends Coord.System>(coordSys: S): ClassIf<S> => {\r\n        // Note: At the time of writing this, separating this into\r\n        // two lines is necessary (otherwise Typescript will feel\r\n        // overwhelmed)\r\n        const ctor = __Constructors[coordSys];\r\n        return ctor as unknown as ClassIf<S>;\r\n    };\r\n\r\n    /**\r\n     * Bounds are inclusive. Ie. the specified values are _just_ allowed.\r\n     *\r\n     * Upper and lower bounds must be strictly positive integer values.\r\n     */\r\n    export type DimensionBounds<S extends Coord.System> = Readonly<{\r\n        [ P in keyof Dimensions<S> ]: Readonly<{\r\n            min: number;\r\n            max: number;\r\n        }>;\r\n    }>;\r\n\r\n}\r\n// Grid gets frozen in PostInit after __Constructors get initialized.\r\n","import { Coord as BaseCoord, Tile } from \"../Tile\";\r\nimport type { VisibleTile } from \"floor/VisibleTile\";\r\nimport { Grid as AbstractGrid } from \"../Grid\";\r\nimport { VisibleGrid } from \"../VisibleGrid\";\r\n\r\n\r\ntype S = BaseCoord.System.EUCLID2;\r\n\r\n/**\r\n *\r\n */\r\nexport namespace Euclid2 {\r\n\r\n    /**\r\n     * # Euclid2 Coord\r\n     */\r\n    export class Coord extends BaseCoord.Abstract.Mathy<S> implements Coord.Bare {\r\n\r\n        public readonly x: number;\r\n        public readonly y: number;\r\n\r\n        public constructor(desc: Coord.Bare) {\r\n            super(desc);\r\n            this.x = desc.x;\r\n            this.y = desc.y;\r\n            Object.freeze(this);\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public equals(other: Coord.Bare): boolean {\r\n            return (this.x === other.x) && (this.y === other.y);\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public round(): Coord {\r\n            return new Coord({\r\n                x: Math.round(this.x),\r\n                y: Math.round(this.y),\r\n            });\r\n        }\r\n\r\n\r\n\r\n        /**\r\n         * Also known as the \"manhattan norm\".\r\n         *\r\n         * _Do not override this._\r\n         *\r\n         * @param other - The norm is taken relative to `other`.\r\n         * @returns The sum of the absolute values of each coordinate.\r\n         */\r\n        public oneNorm(other: Coord.Bare): number {\r\n            return this.sub(other).originOneNorm();\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public originOneNorm(): number {\r\n            return Math.abs(this.x) + Math.abs(this.y);\r\n        }\r\n\r\n        /**\r\n         *\r\n         * _Do not override this._\r\n         *\r\n         * @param other - The norm is taken relative to `other`.\r\n         * @returns The length of the longest dimension.\r\n         */\r\n        public infNorm(other: Coord.Bare): number {\r\n            return this.sub(other).originInfNorm();\r\n        }\r\n\r\n        public originInfNorm(): number {\r\n            return Math.max(Math.abs(this.x), Math.abs(this.y));\r\n        }\r\n\r\n        /**\r\n         * @returns\r\n         * A number in the range (0, 1). `One` means the x and y coordinates\r\n         * align to the x or y axis, and `Zero` means they are plus or minus\r\n         * 45 degrees from the x or y axis.\r\n         *\r\n         * You can try this yourself in [Desmos](https://www.desmos.com/calculator)\r\n         * by pasting in the below code segment and adding a slider for `a`\r\n         * for continuous values between zero and one.\r\n         *\r\n         * ```latex\r\n         * \\frac{\\left|\\left|x\\right|-\\left|y\\right|\\right|}{\\left|x\\right|+\\left|y\\right|}=a\r\n         * ```\r\n         *\r\n         * @param other - The alignment is taken relative to `other`.\r\n         */\r\n        public axialAlignment(other: Coord.Bare): number {\r\n            return this.sub(other).originAxialAlignment();\r\n        }\r\n\r\n        public originAxialAlignment(): number {\r\n            return Math.abs(Math.abs(this.x) - Math.abs(this.y))\r\n                / (Math.abs(this.x) + Math.abs(this.y));\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public add(other: Coord.Bare): Coord {\r\n            return new Coord({\r\n                x: this.x + other.x,\r\n                y: this.y + other.y,\r\n            });\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public sub(other: Coord.Bare): Coord {\r\n            return new Coord({\r\n                x: this.x - other.x,\r\n                y: this.y - other.y,\r\n            });\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public mul(scalar: number): Coord {\r\n            return new Coord({\r\n                x: scalar * this.x,\r\n                y: scalar * this.y,\r\n            });\r\n        }\r\n    }\r\n\r\n    export namespace Coord {\r\n        export type Bare = Readonly<{\r\n            x: number;\r\n            y: number;\r\n        }>;\r\n    }\r\n    Object.freeze(Coord);\r\n    Object.freeze(Coord.prototype);\r\n\r\n\r\n\r\n    /**\r\n     * # Euclid2 Grid\r\n     */\r\n    export class Grid extends AbstractGrid<S> {\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public static getAmbiguityThreshold(): 24 {\r\n            return 24;\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public static getSizeLimits(): AbstractGrid.DimensionBounds<S> { return this.SIZE_LIMITS; }\r\n        private static readonly SIZE_LIMITS = Object.freeze(<const>{\r\n            height: Object.freeze(<const>{ min: 11, max: 51, }),\r\n            width:  Object.freeze(<const>{ min: 11, max: 51, }),\r\n        });\r\n\r\n        /**\r\n         * A 2-dimensional rectangular array with height and width following\r\n         * their corresponding fields, containing `Tile` objects with `pos`\r\n         * fields allowing indexing to themselves. Uses _row-major_ ordering.\r\n         */\r\n        protected readonly grid: TU.RoArr<TU.RoArr<Tile<S>>>;\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public constructor(desc: AbstractGrid.CtorArgs<S>) {\r\n            super(desc);\r\n\r\n            const grid: Array<TU.RoArr<Tile<S>>> = [];\r\n            for (let row = 0; row < this.dimensions.height; row++) {\r\n                const newRow: Array<Tile<S>> = [];\r\n                for (let col = 0; col < this.dimensions.width; col++) {\r\n                    const newTile = new desc.tileClass(new Coord({ x: col, y: row, }));\r\n                    newRow.push(newTile);\r\n                }\r\n                grid.push(newRow);\r\n            }\r\n            this.grid = grid;\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public forEachTile(consumer: (tile: Tile<S>) => void, thisArg: object = this): void {\r\n            this.grid.forEach((row) => row.forEach((tile) => {\r\n                consumer(tile);\r\n            }, thisArg), thisArg);\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public getUntToward(sourceCoord: Coord, intendedDest: Coord.Bare): Tile<S> {\r\n            const options = this.tile.destsFrom(sourceCoord).unoccupied.get;\r\n            if (!(options.some((tile) => tile.coord.equals(sourceCoord)))) {\r\n                // This should never happen. It is here as a reminder.\r\n                throw new Error(\"Caller code didn't break the upward occupancy link.\");\r\n            }\r\n            if (options.length === 1) {\r\n                // Minor optimization:\r\n                return options[0];\r\n            }\r\n            options.sort((tileA, TileB) => {\r\n                // Break (some) ties by one-norm:\r\n                return tileA.coord.oneNorm(intendedDest) - TileB.coord.oneNorm(intendedDest);\r\n            }).sort((tileA, TileB) => {\r\n                // Break (some) ties by one-norm:\r\n                return tileA.coord.infNorm(intendedDest) - TileB.coord.infNorm(intendedDest);\r\n            });\r\n            // Filter out options that are not equally favourable as the\r\n            // most favourable option. I think this is the best method:\r\n            // Note: it is safe to start at index `1` because of the\r\n            // above short-circuit if `options.length === 1`.\r\n            for (let i = 1; i < options.length; i++) {\r\n                if (options[i].coord.infNorm(intendedDest) > options[0].coord.infNorm(intendedDest)) {\r\n                    options.splice(i);\r\n                    break;\r\n                }\r\n            }\r\n            if (options.length === 1) {\r\n                // Minor optimization:\r\n                return options[0];\r\n            }\r\n            // Choose one of the most favourable using some randomness\r\n            // weighted to follow a straight-looking path of movement.\r\n            if (options[0].coord.x - sourceCoord.x === 0 || options[0].coord.y - sourceCoord.y === 0) {\r\n                // (the axial option (if it exists) should be the first\r\n                // due to the previous sort's tie-breaker.\r\n                if (sourceCoord.axialAlignment(sourceCoord.sub(intendedDest)) - 0.5 > 0.0) {\r\n                    // The path to the intended destination is aligned more\r\n                    // with the x or y axis than they are with those axes\r\n                    // rotated 45 degrees.\r\n                    return options[0];\r\n                } else {\r\n                    // Ignore the axial option in further computations:\r\n                    options.shift();\r\n                }\r\n            }\r\n            // Choose a random non-axial option:\r\n            return options[Math.floor(options.length * Math.random())];\r\n        }\r\n\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public __getTileAt(coord: Coord.Bare): Tile<S> {\r\n            if (coord.x < 0 || coord.x >= this.dimensions.width ||\r\n                coord.y < 0 || coord.y >= this.dimensions.height\r\n            ) {\r\n                throw new RangeError(\"Out of bounds. No such tile exists.\");\r\n            }\r\n            return this.grid[coord.y][coord.x];\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public __getTileDestsFrom(coord: Coord.Bare, radius: number = 1): Array<Tile<S>> {\r\n            let t = coord.y - radius;\r\n            let b = coord.y + radius + 1;\r\n            let l = coord.x - radius;\r\n            let r = coord.x + radius + 1;\r\n            if (t >= this.dimensions.height || b < 0\r\n             || l >= this.dimensions.width  || r < 0) return [];\r\n            return this.grid.slice(\r\n                // filter for included rows:\r\n                Math.max(0, t),\r\n                Math.min(this.dimensions.height, b),\r\n            ).flatMap((gridRow) => gridRow.slice(\r\n                // filter for included slices of rows (columns):\r\n                Math.max(0, l),\r\n                Math.min(this.dimensions.width, r),\r\n            ));\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public __getTileSourcesTo(coord: Coord.Bare, radius: number = 1): Array<Tile<S>> {\r\n            // Same behaviour as getting destinations from `coord`.\r\n            return this.__getTileDestsFrom(coord, radius);\r\n        }\r\n\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public static getSpawnCoords(\r\n            playerCounts: number,\r\n            dimensions: Grid.Dimensions,\r\n        ):  TU.RoArr<Coord.Bare> {\r\n            return [{x:0,y:0,},];\r\n\r\n            // TODO.impl A proper, nice looking version of this.\r\n            //\r\n            //\r\n            //\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public static getArea(dim: Grid.Dimensions): number {\r\n            return dim.height * dim.width;\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public static getRandomCoord(dimensions: Grid.Dimensions): Coord {\r\n            return new Coord(undefined!);\r\n        }\r\n    }\r\n\r\n    export namespace Grid {\r\n        /**\r\n         * If `width` is not specified, `height` is taken as its default value.\r\n         */\r\n        export type Dimensions = {\r\n            height: number,\r\n            width:  number,\r\n        };\r\n\r\n        export class Visible extends Grid implements VisibleGrid<S> {\r\n            public readonly baseElem: HTMLElement;\r\n\r\n            /**\r\n             * @override\r\n             */\r\n            declare protected readonly grid: TU.RoArr<TU.RoArr<VisibleTile<S>>>;\r\n\r\n            public constructor(desc: AbstractGrid.CtorArgs<S>) {\r\n                super(desc);\r\n                const gridElem = document.createElement(\"div\");\r\n                gridElem.style.setProperty(\"--euclid2-grid-width\",  this.dimensions.width.toString());\r\n                //gridElem.style.setProperty(\"--euclid2-grid-height\", this.dimensions.height.toString());\r\n                for (const row of this.grid) {\r\n                    for (const tile of row) {\r\n                        tile.__addToDom(gridElem);\r\n                    }\r\n                }\r\n                this.__VisibleGrid_super(desc, gridElem);\r\n            }\r\n        }\r\n    }\r\n    Object.freeze(Grid);\r\n    Object.freeze(Grid.prototype);\r\n\r\n}\r\nObject.freeze(Euclid2);\r\n","import { Coord as BaseCoord, Tile } from \"../Tile\";\r\nimport type { VisibleTile } from \"floor/VisibleTile\";\r\nimport { Grid as AbstractGrid } from \"../Grid\";\r\nimport { VisibleGrid } from \"../VisibleGrid\";\r\n\r\n\r\ntype S = BaseCoord.System.BEEHIVE;\r\n\r\n/**\r\n * #  BEES !\r\n *\r\n * #  BEES !\r\n *\r\n * #  BEES !\r\n *\r\n * ```text\r\n *   ___   ___\r\n *  //  \\_//  \\__\r\n *  \\\\__/  \\__/  \\\r\n *     \\\\__/ \\\\__/\r\n * ```\r\n *\r\n *\r\n * [(bees)](https://giphy.com/gifs/oprah-bees-VhFps32TlNgsg)\r\n */\r\nexport namespace Beehive {\r\n\r\n    /**\r\n     * # Beehive Coord\r\n     */\r\n    export class Coord extends BaseCoord.Abstract.Mathy<S> implements Coord.Bare {\r\n\r\n        /**\r\n         * #  3'o'clock direction\r\n         */\r\n        public readonly dash: number;\r\n\r\n        /**\r\n         * #  5'o'clock direction\r\n         */\r\n        public readonly bash: number;\r\n\r\n        public constructor(desc: Coord.Bare) {\r\n            super(desc);\r\n            this.dash = desc.dash;\r\n            this.bash = desc.bash;\r\n            Object.freeze(this);\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public equals(other: Coord.Bare): boolean {\r\n            return (this.dash === other.dash) && (this.bash === other.bash);\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public round(): Coord {\r\n            // I'm pretty proud of this despite the fact that I don't\r\n            // think there's anything very impressive about it.\r\n            const floorDash = Math.floor(this.dash);\r\n            const floorBash = Math.floor(this.bash);\r\n            const d = floorDash - this.dash;\r\n            const b = floorBash - this.bash;\r\n            if (d > 2 * b) {\r\n                return new Coord({ dash: floorDash+1, bash: floorBash  , });\r\n            } else if (d < 0.5 * b) {\r\n                return new Coord({ dash: floorDash  , bash: floorBash+1, });\r\n            } else if (Math.min(d, b) > 0.5) {\r\n                return new Coord({ dash: floorDash+1, bash: floorBash+1, });\r\n            } else {\r\n                return new Coord({ dash: floorDash  , bash: floorBash  , });\r\n            }\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public add(other: Coord.Bare): Coord {\r\n            return new Coord({\r\n                dash: this.dash + other.dash,\r\n                bash: this.bash + other.bash,\r\n            });\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public sub(other: Coord.Bare): Coord {\r\n            return new Coord({\r\n                dash: this.dash - other.dash,\r\n                bash: this.bash - other.bash,\r\n            });\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public mul(scalar: number): Coord {\r\n            return new Coord({\r\n                dash: scalar * this.dash,\r\n                bash: scalar * this.bash,\r\n            });\r\n        }\r\n    }\r\n\r\n    export namespace Coord {\r\n        export type Bare = Readonly<{\r\n            dash: number;\r\n            bash: number;\r\n        }>;\r\n    }\r\n    Object.freeze(Coord);\r\n    Object.freeze(Coord.prototype);\r\n\r\n\r\n\r\n    /**\r\n     * # Beehive Grid\r\n     */\r\n    export class Grid extends AbstractGrid<S> {\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public static getAmbiguityThreshold(): 18 {\r\n            return 18;\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public static getSizeLimits(): AbstractGrid.DimensionBounds<S> { return this.SIZE_LIMITS; }\r\n        private static readonly SIZE_LIMITS = Object.freeze({\r\n            dash:    Object.freeze({ min: 10, max: 50, }),\r\n            bslash:  Object.freeze({ min: 10, max: 50, }),\r\n            fslash:  Object.freeze({ min: 10, max: 50, }),\r\n        });\r\n\r\n        /**\r\n         *\r\n         */\r\n        // TODO.design determine spec for indexing\r\n        // Then initialize the field in the constructor\r\n        // Also design HTML representation and initialize in Grid.Visible\r\n        private readonly grid: TU.RoArr<TU.RoArr<Tile<S>>>;\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public constructor(desc: AbstractGrid.CtorArgs<S>) {\r\n            super(desc);\r\n\r\n            // Initialize `grid`:\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public forEachTile(consumer: (tile: Tile<S>) => void, thisArg: object = this): void {\r\n            this.grid.forEach((row) => row.forEach((tile) => {\r\n                consumer(tile);\r\n            }, thisArg), thisArg);\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public getUntToward(sourceCoord: Coord, intendedDest: Coord.Bare): Tile<S> {\r\n            return undefined!;\r\n        }\r\n\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public __getTileAt(coord: Coord.Bare): Tile<S> {\r\n            return undefined!;\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public __getTileDestsFrom(coord: Coord.Bare): Array<Tile<S>> {\r\n            return undefined!;\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public __getTileSourcesTo(coord: Coord.Bare): Array<Tile<S>> {\r\n            return undefined!;\r\n        }\r\n\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public static getSpawnCoords(\r\n            playerCounts: number,\r\n            dimensions: Grid.Dimensions,\r\n        ): ReadonlyArray<Coord.Bare> {\r\n            return undefined!;\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public static getArea(dim: Grid.Dimensions): number {\r\n            const shorterSide = Math.min(dim.fslash, dim.bslash);\r\n            const longerSide  = Math.max(dim.fslash, dim.bslash);\r\n            const width = (-1) + dim.dash + shorterSide;\r\n            let area = 2 * shorterSide * (dim.dash + width);\r\n            area += (longerSide - shorterSide - 1) * width;\r\n            return area;\r\n        }\r\n\r\n        /**\r\n         * @override\r\n         */\r\n        public static getRandomCoord(dimensions: Grid.Dimensions): Coord {\r\n            return new Coord(undefined!);\r\n        }\r\n    }\r\n\r\n    export namespace Grid {\r\n        export type Dimensions = {\r\n            dash: number;\r\n            bslash: number;\r\n            fslash: number;\r\n        };\r\n\r\n        export class Visible extends Grid implements VisibleGrid<S> {\r\n            public readonly baseElem: HTMLElement;\r\n            public constructor(desc: AbstractGrid.CtorArgs<S>) {\r\n                super(desc);\r\n                const domGrid: HTMLElement = undefined!;\r\n                // TODO.impl Beehive VisibleGrid ctor.\r\n                this.__VisibleGrid_super(desc, domGrid);\r\n            }\r\n        }\r\n    }\r\n    Object.freeze(Grid);\r\n    Object.freeze(Grid.prototype);\r\n\r\n}\r\nObject.freeze(Beehive);\r\n","import { Grid } from \"floor/Grid\";\r\nimport { VisibleGrid } from \"floor/VisibleGrid\";\r\n\r\nimport { Euclid2 } from \"floor/impl/Euclid2\";\r\nimport { Beehive } from \"floor/impl/Beehive\";\r\n\r\nimport { ArtificialPlayer } from \"./player/ArtificialPlayer\";\r\nimport { Chaser } from \"./player/artificials/Chaser\";\r\n\r\n\r\n/**\r\n *\r\n */\r\nexport namespace IndexTasks {\r\n\r\n    /**\r\n     * This function should be imported and run at the beginning of each\r\n     * index.js file before calling any constructors for SnaKey-related\r\n     * classes.\r\n     *\r\n     * It serves the dual purpose of initializing implementation\r\n     * registries _after_ implementations and their class hierarchy have\r\n     * been defined, and of importing implementations so they don't get\r\n     * tree-shaken-out by webpack.\r\n     */\r\n    export function INIT_CLASS_REGISTRIES(): void\r\n    { {\r\n        // Non-Visible Grid Implementation Registry:\r\n        (<TU.NoRo<typeof Grid.__Constructors>>Grid.__Constructors)\r\n        = Object.freeze({\r\n            [ \"EUCLID2\" ]: Euclid2.Grid,\r\n            [ \"BEEHIVE\" ]: Beehive.Grid,\r\n        });\r\n        Object.freeze(Grid);\r\n        Object.freeze(Grid.prototype);\r\n    } {\r\n        // Visible Grid Implementation Registry:\r\n        const VGr = VisibleGrid;\r\n        (<TU.NoRo<typeof VGr.__Constructors>>VGr.__Constructors)\r\n        = Object.freeze({\r\n            [ \"EUCLID2\" ]: Euclid2.Grid.Visible,\r\n            [ \"BEEHIVE\" ]: Beehive.Grid.Visible,\r\n        });\r\n        Object.freeze(VGr);\r\n        // This is just an interface. There is no instance prototype to freeze.\r\n    } {\r\n        const AP = ArtificialPlayer;\r\n        (<TU.NoRo<typeof AP.__Constructors>>AP.__Constructors)\r\n        = Object.freeze({\r\n            CHASER: Chaser,\r\n        });\r\n        Object.freeze(AP);\r\n        Object.freeze(AP.prototype);\r\n    } }\r\n    Object.freeze(INIT_CLASS_REGISTRIES);\r\n}\r\nObject.freeze(IndexTasks);","import { Game } from \"../Game\";\r\nimport type { Lang } from 'utils/TypeDefs';\r\nimport type { Coord, Tile } from \"floor/Tile\";\r\nimport type { Grid } from \"floor/Grid\";\r\nimport type { VisibleGrid } from \"floor/VisibleGrid\";\r\n\r\nimport { Player, PlayerStatus, Team } from \"../player/Player\";\r\nimport type { OperatorPlayer } from \"../player/OperatorPlayer\";\r\nimport type { ArtificialPlayer } from \"../player/ArtificialPlayer\";\r\nimport type { PlayerActionEvent } from \"game/events/PlayerActionEvent\";\r\n\r\n\r\n/**\r\n * Foundational parts of a Game that are not related to event handling.\r\n */\r\nexport abstract class GameBase<G extends Game.Type, S extends Coord.System> {\r\n\r\n    public readonly gameType: G;\r\n\r\n    public readonly grid: G extends Game.Type.SERVER ? Grid<S> : VisibleGrid<S>;\r\n\r\n    protected readonly players: TU.RoArr<Player<S>>;\r\n\r\n    public readonly operator: G extends Game.Type.SERVER ? undefined : OperatorPlayer<S>;\r\n\r\n    /**\r\n     * Indexable by team ID's.\r\n     */\r\n    public readonly teams: TU.RoArr<Team<S>>;\r\n\r\n    #status: Game.Status;\r\n\r\n    public readonly __playerStatusCtor: typeof PlayerStatus;\r\n\r\n\r\n    /**\r\n     * _Does not call reset._\r\n     *\r\n     * Performs the \"no invincible player\" check (See {@link Player#teamSet}).\r\n     *\r\n     * @param gameType -\r\n     * @param impl -\r\n     * @param desc -\r\n     */\r\n    public constructor(\r\n        gameType: G,\r\n        impl: Game.ImplArgs<S>,\r\n        desc: Game.CtorArgs<G,S>,\r\n    ) {\r\n        this.gameType = gameType;\r\n        const gridClass = this.__getGridImplementation(desc.coordSys);\r\n        this.grid = new (gridClass)({\r\n            gridClass:  gridClass,\r\n            tileClass:  impl.tileClass,\r\n            coordSys:   desc.coordSys,\r\n            dimensions: desc.gridDimensions,\r\n            domParentHtmlIdHook: (desc.gridHtmlIdHook || \"n/a\")!,\r\n        }) as GameBase<G,S>[\"grid\"];\r\n\r\n        // Construct players:\r\n        this.__playerStatusCtor = impl.playerStatusCtor;\r\n        this.players = this.createPlayers(desc);\r\n        if (desc.operatorIndex !== undefined) {\r\n            // Note at above comparison: we must be explicit\r\n            // since zero is a valid, _falsy_ operatorIndex.\r\n            (this.operator as Player<S>) = this.players[desc.operatorIndex!];\r\n        }\r\n        const teams: Array<Array<Player<S>>> = [];\r\n        this.players.forEach((player) => {\r\n            if (!teams[player.teamId]) {\r\n                teams[player.teamId] = [];\r\n            }\r\n            teams[player.teamId].push(player);\r\n        });\r\n        this.teams = teams.map((teammateArray, teamId) => {\r\n            return new Team<S>(teamId, teammateArray);\r\n        });\r\n        if (this.teams.every((team) => team.id === Team.ElimOrder.IMMORTAL)) {\r\n            // TODO.design put a check inside the UI code to prevent this.\r\n            // The purpose of this restriction is to prevent DoS attacks on\r\n            // a hosting server by creating games that can never end and\r\n            // leaving them open forever, thus leaking the server's resources.\r\n            throw new Error(\"All teams are immortal. The game will never end.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reset the grid.\r\n     */\r\n    public reset(): void {\r\n        this.grid.reset();\r\n        // We must reset status to PAUSED to pass a state-transition\r\n        // assertion when changing status later to PLAYING.\r\n        this.#status = Game.Status.PAUSED;\r\n    }\r\n\r\n    protected abstract __getGridImplementation(coordSys: S):\r\n    G extends Game.Type.SERVER ? Grid.ClassIf<S> : VisibleGrid.ClassIf<S>;\r\n\r\n\r\n    /**\r\n     * Private helper for the constructor to create player objects.\r\n     * This is bypassed in non-game-manager implementations (Ie. In\r\n     * OnlineGame).\r\n     *\r\n     * @param gameDesc -\r\n     * @returns A bundle of the constructed players.\r\n     */\r\n    private createPlayers(gameDesc: Readonly<Game.CtorArgs<G,S>>): GameBase<G,S>[\"players\"] {\r\n        type pCtorArgs = TU.RoArr<Player.CtorArgs>;\r\n        const playerDescs: pCtorArgs\r\n            = (gameDesc.playerDescs as pCtorArgs)\r\n            = (this.gameType === Game.Type.ONLINE)\r\n            // The client receives these descriptors already finalized / cleaned by the server.\r\n            ? gameDesc.playerDescs as pCtorArgs\r\n            : Player.CtorArgs.finalize(gameDesc.playerDescs, gameDesc.languageName);\r\n\r\n        return playerDescs.map((playerDesc, playerIndex) => {\r\n            if (playerDesc.familyId === Player.Family.HUMAN) {\r\n                return (playerIndex === gameDesc.operatorIndex)\r\n                    ? this.__createOperatorPlayer(playerDesc)\r\n                    : new Player(this, playerDesc);\r\n            } else {\r\n                return this.__createArtifPlayer(playerDesc);\r\n            }\r\n        });\r\n    }\r\n    protected abstract __createOperatorPlayer(desc: Player.CtorArgs): OperatorPlayer<S>;\r\n    protected abstract __createArtifPlayer(desc: Player.CtorArgs):\r\n    (G extends Game.Type.Manager ? ArtificialPlayer<S> : Player<S>);\r\n\r\n    public serializeResetState(): Game.ResetSer<S> {\r\n        const csps: Array<Lang.CharSeqPair> = [];\r\n        const playerCoords = this.players.map((player) => player.coord);\r\n        const healthCoords: TU.NoRo<Game.ResetSer<S>[\"healthCoords\"]> = [];\r\n        this.grid.forEachTile((tile) => {\r\n            csps.push({\r\n                char: tile.langChar,\r\n                seq:  tile.langSeq,\r\n            });\r\n            if (tile.freeHealth) {\r\n                healthCoords.push({\r\n                    coord:  tile.coord,\r\n                    health: tile.freeHealth,\r\n                })\r\n            }\r\n        });\r\n        return { csps, playerCoords, healthCoords, };\r\n    }\r\n\r\n    public deserializeResetState(ser: Game.ResetSer<S>): void {\r\n        { let i = 0;\r\n        // Could also use `csps.unshift`, but that may be slower\r\n        // because it modifies csps, which we don't need to do.\r\n        this.grid.forEachTile((tile) => {\r\n            tile.setLangCharSeqPair(ser.csps[i++]);\r\n        }); }\r\n        ser.playerCoords.forEach((coord, index) => {\r\n            this.players[index].moveTo(this.grid.tile.at(coord));\r\n        });\r\n        ser.healthCoords.forEach((desc) => {\r\n            this.grid.tile.at(desc.coord).freeHealth = desc.health;\r\n        });\r\n    }\r\n\r\n\r\n    public get status(): Game.Status {\r\n        return this.#status;\r\n    }\r\n    public statusBecomePlaying(): void {\r\n        if (this.status !== Game.Status.PAUSED) {\r\n            throw new Error(\"Can only resume a game that is currently paused.\");\r\n        }\r\n        this.players.forEach((player) => {\r\n            player.__abstractNotifyThatGameStatusBecamePlaying();\r\n        });\r\n        this.__abstractStatusBecomePlaying();\r\n        this.#status = Game.Status.PLAYING;\r\n        // Make sure focus goes back to the grid element so that it\r\n        // can pick up user input as keydown events:\r\n        if ((this.grid as VisibleGrid<S>).baseElem) {\r\n            (this.grid as VisibleGrid<S>).baseElem.focus();\r\n        }\r\n    }\r\n    public statusBecomePaused(): void {\r\n        if (this.status !== Game.Status.PLAYING) {\r\n            throw new Error(\"Can only pause a game that is currently playing.\");\r\n        }\r\n        this.players.forEach((player) => {\r\n            player.__abstractNotifyThatGameStatusBecamePaused();\r\n        });\r\n        this.__abstractStatusBecomePaused();\r\n        this.#status = Game.Status.PAUSED;\r\n    }\r\n    public statusBecomeOver(): void {\r\n        if (this.status !== Game.Status.PLAYING) {\r\n            throw new Error(\"Can only end a game that is currently playing.\");\r\n        }\r\n        this.players.forEach((player) => {\r\n            player.__abstractNotifyThatGameStatusBecameOver();\r\n        });\r\n        this.__abstractStatusBecomeOver();\r\n        this.#status = Game.Status.OVER;\r\n    }\r\n    protected __abstractStatusBecomePlaying(): void {}\r\n    protected __abstractStatusBecomePaused(): void {}\r\n    protected __abstractStatusBecomeOver(): void {}\r\n\r\n\r\n    public abstract setTimeout(callback: Function, millis: number, ...args: any[])\r\n    : G extends Game.Type.SERVER ? NodeJS.Timeout : number;\r\n\r\n    public abstract cancelTimeout(handle: number | NodeJS.Timeout): void;\r\n\r\n /* The implementations are fully defined and publicly exposed by\r\n    GameManager. These protected declarations higher up the class\r\n    hierarchy exist to allow OnlineGame to override them to send\r\n    a request to the ServerGame. */\r\n    public abstract processMoveRequest(desc: PlayerActionEvent.Movement<S>): void;\r\n    protected abstract processBubbleRequest(desc: PlayerActionEvent.Bubble): void;\r\n\r\n}\r\nObject.freeze(GameBase);\r\nObject.freeze(GameBase.prototype);\r\n","import type { Coord } from \"floor/Tile\";\r\nimport { Game } from \"../Game\";\r\n\r\nimport { PlayerActionEvent, TileModificationEvent } from \"../events/PlayerActionEvent\";\r\nimport { EventRecordEntry } from \"../events/EventRecordEntry\";\r\n\r\nimport { GameBase } from \"./Base\";\r\n\r\n\r\n/**\r\n * All events have two corresponding handler functions taking a\r\n * request descriptor object (\"desc\"):\r\n *\r\n * ### Request Processor\r\n *\r\n * The request processor is only used by the Game Manager. It decides\r\n * whether to accept or reject the request based on `desc` and may\r\n * throw exceptions on impossible arguments. It should not make any\r\n * changes to the game state. Instead, it is responsible to augment\r\n * `desc` with information describing what changes to the game state\r\n * must be made.\r\n *\r\n * ### Request Executor\r\n *\r\n * This takes the `desc` augmented by the request processor and enacts\r\n * all the described changes upon the game's state. If the Game Manager\r\n * is not local to the client (a server process), then this handler is\r\n * called at both the server and client.\r\n *\r\n * Updates the event record if the response is accepted.\r\n */\r\nexport abstract class GameEvents<G extends Game.Type, S extends Coord.System> extends GameBase<G,S> {\r\n\r\n    /**\r\n     * All copies of the game should contain identical entries. That\r\n     * in a {@link OnlineGame} may at any instant be missing trailing\r\n     * entries, or contain some trailing holes, but such gaps should\r\n     * eventually be filled to match those in the Game Manager.\r\n     *\r\n     * Do not modify this directly. To register an accepted event,\r\n     * call the {@link Game#recordEvent} method, passing it the event\r\n     * descriptor. To create a new event ID at the Game Manager, just\r\n     * take the current length of this array.\r\n     */\r\n    private readonly eventRecord: Array<Readonly<EventRecordEntry>>;\r\n\r\n    public constructor(\r\n        gameType: G,\r\n        impl: Game.ImplArgs<S>,\r\n        gameDesc: Game.CtorArgs<G,S>,\r\n    ) {\r\n        super(gameType, impl, gameDesc);\r\n        this.eventRecord = [];\r\n    }\r\n\r\n    public reset(): void {\r\n        // Clear the event record:\r\n        this.eventRecord.splice(0);\r\n\r\n        super.reset();\r\n    }\r\n\r\n    protected getNextUnusedEventId(): EventRecordEntry[\"eventId\"] {\r\n        return this.eventRecord.length;\r\n    }\r\n\r\n\r\n    /**\r\n     * Basically does `this.eventRecord[id] = desc;` with value checking.\r\n     *\r\n     * @param desc -\r\n     *\r\n     * @throws\r\n     * In the given order of priority:\r\n     * - TypeError if the event ID indicates a rejected request\r\n     * - RangeError if it is not a positive integer\r\n     * - Error if another event was already recorded with the same ID.\r\n     */\r\n    private recordEvent(desc: Readonly<EventRecordEntry>): void {\r\n        const id = desc.eventId;\r\n        if (id === EventRecordEntry.EVENT_ID_REJECT) {\r\n            throw new TypeError(\"Do not try to record events for rejected requests.\");\r\n        } else if (id < 0 || id !== Math.trunc(id)) {\r\n            throw new RangeError(\"Event ID's must only be assigned positive, integer values.\");\r\n        } else if (this.eventRecord[id]) {\r\n            throw new Error(\"Event ID's must be assigned unique values.\");\r\n        }\r\n        // NOTE: If storage becomes a concern with logging events,\r\n        // create a static constant for the record's buffer size,\r\n        // and then here, wrap around.\r\n        this.eventRecord[id] = desc;\r\n    }\r\n\r\n\r\n    private executeTileModificationsEvent(\r\n        desc: TileModificationEvent<S>,\r\n        doCheckOperatorSeqBuffer: boolean = true,\r\n    ): void {\r\n        const dest = this.grid.tile.at(desc.coord);\r\n        if (dest.lastKnownUpdateId < desc.lastKnownUpdateId) {\r\n            if (desc.newCharSeqPair) {\r\n                dest.setLangCharSeqPair(desc.newCharSeqPair);\r\n                // Refresh the operator's `seqBuffer` (maintain invariant) for new CSP:\r\n                if (doCheckOperatorSeqBuffer && this.operator !== undefined\r\n                    && !(this.operator.tile.destsFrom().get.includes(dest))) {\r\n                    // ^Do this when non-operator moves into the the operator's vicinity.\r\n                    this.operator.seqBufferAcceptKey(\"\");\r\n                }\r\n            }\r\n            dest.lastKnownUpdateId = desc.lastKnownUpdateId;\r\n            dest.freeHealth = desc.newFreeHealth!;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the {@link Game#grid}. Call either at the end of\r\n     * {@link Game#processMoveRequest} if I am a {@link ServerGame} or\r\n     * {@link OfflineGame}, or as an event callback if I am a\r\n     * {@link OnlineGame}.\r\n     *\r\n     * Automatically lowers the {@link Player#requestInFlight} field\r\n     * for the requesting `Player` if the arriving event description\r\n     * is the newest one for the specified `Player`.\r\n     *\r\n     * Updates that are received after others that are more recent and\r\n     * concern the same {@link Tile} are ignored. This is okay since\r\n     * the only thing that matters about a {@link Tile} to the outside\r\n     * world is its last known state.\r\n     *\r\n     * @param desc\r\n     * A descriptor for all changes mandated by the player-movement event.\r\n     */\r\n    protected processMoveExecute(desc: Readonly<PlayerActionEvent.Movement<S>>): void {\r\n        const player = this.players[desc.playerId];\r\n        const dest   = this.grid.tile.at(desc.dest.coord);\r\n        const clientEventLag = desc.playerLastAcceptedRequestId - player.lastAcceptedRequestId;\r\n\r\n        if (desc.eventId === EventRecordEntry.EVENT_ID_REJECT) {\r\n            // Rejected request. Implies either that: clientEventLag === 0,\r\n            // or that (at Game Manager): dest.numTimesOccupied > desc.destNumTimesOccupied\r\n            if (clientEventLag === 1) {\r\n                player.requestInFlight = false;\r\n            }\r\n            return; // Short-circuit!\r\n        }\r\n        this.recordEvent(desc);\r\n        this.executeTileModificationsEvent(desc.dest, player !== this.operator);\r\n        desc.tilesWithHealthUpdates!.forEach((desc) => {\r\n            this.executeTileModificationsEvent(desc);\r\n        });\r\n\r\n        if (clientEventLag > 1) {\r\n            // ===== Out of order receipt (client-side) =====\r\n            // Already received more recent request responses.\r\n            if (player === this.operator) {\r\n                // Operator never receives their own updates out of\r\n                // order because they only have one unacknowledged\r\n                // in-flight request at a time.\r\n                throw new Error(\"This never happens. See comment in source.\");\r\n            }\r\n            return; // Short-circuit!\r\n        }\r\n        // Okay- the response is an acceptance of the specified player's most\r\n        // recent request pending this acknowledgement.\r\n        player.requestInFlight = false;\r\n        if ((player === this.operator)\r\n            ? (clientEventLag === 1)\r\n            : (clientEventLag <= 1)) {\r\n            player.status.score     = desc.newPlayerHealth!.score;\r\n            player.status.health = desc.newPlayerHealth!.health;\r\n\r\n            player.moveTo(dest);\r\n            // Below is computationally the same as \"(player.lastAcceptedRequestId)++\"\r\n            player.lastAcceptedRequestId = desc.playerLastAcceptedRequestId;\r\n\r\n        } else {\r\n            // Apparent negative lag. The operator may somehow have\r\n            // tampered with their player's request counter.\r\n            throw new Error(\"This never happens. See comment in source\");\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     *\r\n     * Automatically lowers the {@link Player#requestInFlight} field\r\n     * for the requesting `Player`.\r\n     *\r\n     * @param desc -\r\n     */\r\n    protected processBubbleExecute(desc: Readonly<PlayerActionEvent.Bubble>): void {\r\n        // TODO.impl Visually highlight the affected tiles for the specified estimate-duration.\r\n        const bubbler = this.players[desc.playerId];\r\n\r\n        bubbler.requestInFlight = false;\r\n\r\n        if (desc.eventId !== EventRecordEntry.EVENT_ID_REJECT) {\r\n            this.recordEvent(desc); // Record the event.\r\n        }\r\n    }\r\n\r\n}\r\nObject.freeze(GameEvents);\r\nObject.freeze(GameEvents.prototype);\r\n","import { Lang } from \"lang/Lang\";\r\nimport { Game } from \"game/Game\";\r\n\r\nimport type { Coord, Tile } from \"floor/Tile\";\r\nimport type { Player } from \"../player/Player\";\r\n\r\nimport { PlayerGeneratedRequest } from \"../events/EventRecordEntry\";\r\nimport { PlayerActionEvent, TileModificationEvent } from \"../events/PlayerActionEvent\";\r\n\r\nimport { English } from \"lang/impl/English\"; // NOTE: temporary placeholder.\r\nimport { GameEvents } from \"game/__gameparts/Events\";\r\n\r\n\r\n/**\r\n *\r\n */\r\nexport abstract class GameManager<G extends Game.Type, S extends Coord.System> extends GameEvents<G,S> {\r\n\r\n    public readonly averageFreeHealth: Player.Health;\r\n    protected currentFreeHealth: Player.Health; // TODO.impl maintain this field. and use it to spawn in health.\r\n\r\n    public readonly lang: Lang;\r\n\r\n    /**\r\n     * NOTE: Shuffling operations and the\r\n     * {@link Lang} implementation are able to support mid-game changes\r\n     * to the balancing behaviour. Making it fixed for the lifetime of\r\n     * a `Game` is a choice I made in order to make the user experience\r\n     * more simple. It's one less thing they'll see in the in-game UI,\r\n     * and I don't think they'd feel as if it were missing.\r\n     */\r\n    protected readonly langBalancingScheme: Lang.BalancingScheme;\r\n\r\n    /**\r\n     * _Does not call reset._\r\n     *\r\n     * Performs the \"no invincible player\" check (See {@link Player#teamSet}).\r\n     *\r\n     * @param gameType -\r\n     * @param impl -\r\n     * @param desc -\r\n     */\r\n    public constructor(\r\n        gameType: G,\r\n        impl: Game.ImplArgs<S>,\r\n        desc: Game.CtorArgs<G,S>,\r\n    ) {\r\n        super(gameType, impl, desc);\r\n        this.averageFreeHealth = desc.averageFreeHealthPerTile * this.grid.area;\r\n\r\n        // TODO.impl Change this to use a dynamic import for a Lang registry dict.\r\n        // We need to make that registry dict first!\r\n        this.lang = English.Lowercase.getInstance();\r\n\r\n        // TODO.impl Enforce this in the UI code by greying out unusable combos of lang and coord-sys.\r\n        const minLangLeaves = this.grid.static.getAmbiguityThreshold();\r\n        if (this.lang.numLeaves < minLangLeaves) {\r\n            throw new Error(`Found ${this.lang.numLeaves} leaves, but at`\r\n            + ` least ${minLangLeaves} were required. The provided mappings`\r\n            + ` composing the current Lang-under-construction are not`\r\n            + ` sufficient to ensure that a shuffling operation will always`\r\n            + ` be able to find a safe candidate to use as a replacement.`\r\n            + ` Please see the spec for Lang.getNonConflictingChar.`\r\n            );\r\n        }\r\n        this.langBalancingScheme = desc.langBalancingScheme;\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    public reset(): void {\r\n        // Reset the grid and event record:\r\n        super.reset();\r\n\r\n        this.currentFreeHealth = 0.0;\r\n\r\n        // Reset hit-counters in the current language:\r\n        // This must be done before shuffling so that the previous\r\n        // history of shuffle-ins has no effects on the new pairs.\r\n        this.lang.reset();\r\n        // Shuffle everything:\r\n        this.grid.forEachTile((tile) => {\r\n            tile.setLangCharSeqPair(this.dryRunShuffleLangCharSeqAt(tile));\r\n        });\r\n\r\n        // Reset and spawn players:\r\n        this.teams.forEach((team) => team.reset());\r\n        const spawnPoints = this.grid.static.getSpawnCoords(\r\n            this.players.length,\r\n            this.grid.dimensions,\r\n        );\r\n        this.players.forEach((player) => {\r\n            player.reset(this.grid.tile.at(spawnPoints[player.playerId]));\r\n        });\r\n\r\n        // TODO.impl Targets should be spawned _after_ players have\r\n        // spawned so they do not spawn in the same tile as any players.\r\n    }\r\n\r\n\r\n    /**\r\n     * **Important:** Nullifies the existing values at `tile` and does\r\n     * not consume the returned values, which must be done externally.\r\n     *\r\n     * @param targetTile\r\n     * The {@link Tile} to shuffle their {@link Lang.CharSeqPair}\r\n     * pair for.\r\n     *\r\n     * @returns\r\n     * A {@link Lang.CharSeqPair} that can be used as a replacement\r\n     * for that currently being used by `tile`.\r\n     */\r\n    public dryRunShuffleLangCharSeqAt(targetTile: Tile<S>): Lang.CharSeqPair {\r\n        // First, clear values for the target tile so its current\r\n        // (to-be-previous) values don't get unnecessarily avoided.\r\n        targetTile.setLangCharSeqPair(Lang.CharSeqPair.NULL);\r\n\r\n        const avoid: TU.RoArr<Tile<S>> = Array.from(new Set(\r\n            this.grid.tile.sourcesTo(targetTile.coord).get\r\n            .flatMap((sourceToTarget) => this.grid.tile.destsFrom(sourceToTarget.coord).get)\r\n        ));\r\n        return this.lang.getNonConflictingChar(avoid\r\n                .map((tile) => tile.langSeq)\r\n                .filter((seq) => seq), // no falsy values.\r\n            this.langBalancingScheme,\r\n        );\r\n    }\r\n\r\n    // TODO.design what arguments must this take?\r\n    // then we need to implement it.\r\n    public dryRunSpawnFreeHealth(): TU.RoArr<TileModificationEvent<S>> {\r\n        return [];\r\n        // NOTE to self: make sure to update this.currentFreeHealth.\r\n    }\r\n\r\n\r\n    /**\r\n     * Perform checks on an incoming event request for some action that\r\n     * a player can perform while the game is playing (ie. not paused\r\n     * or over).\r\n     *\r\n     * @param desc -\r\n     * @returns\r\n     * The player specified by the given ID, or undefined if the\r\n     * game is not playing, in which case the event request should\r\n     * be rejected.\r\n     *\r\n     * @throws\r\n     * `RangeError` if the request was made before receiving an\r\n     * acknowledgement for the previous request, or if the given ID\r\n     * does not belong to any existing player.\r\n     */\r\n    private managerCheckGamePlayingRequest(desc: PlayerGeneratedRequest): Player<S> | undefined {\r\n        if (this.status !== Game.Status.PLAYING) {\r\n            return undefined;\r\n        }\r\n        const player = this.players[desc.playerId];\r\n        if (!player) {\r\n            throw new Error(\"No such player exists.\");\r\n        }\r\n        if (desc.playerLastAcceptedRequestId !== player.lastAcceptedRequestId) {\r\n            throw new RangeError((desc.playerLastAcceptedRequestId < player.lastAcceptedRequestId)\r\n            ? (\"Clients should not make requests until they have\"\r\n                + \" received my response to their last request.\")\r\n            : (\"Client seems to have incremented the request ID\"\r\n                + \" counter on their own, which is is illegal.\")\r\n            );\r\n        }\r\n        return player;\r\n    }\r\n\r\n\r\n    /**\r\n     * @see PlayerMovementEvent\r\n     *\r\n     * Reject the request if `dest` is occupied, or if the specified\r\n     * player does not exist, or the client is missing updates for the\r\n     * destination they requested to move to, or the player is bubbling.\r\n     *\r\n     * @param desc\r\n     * A descriptor of the request describing the requester's views\r\n     * of critical parts of the game-state from their copy of the game\r\n     * state at the time of the request. Is modified to describe changes\r\n     * to be made.\r\n     */\r\n    public processMoveRequest(desc: PlayerActionEvent.Movement<S>): void {\r\n        const player = this.managerCheckGamePlayingRequest(desc);\r\n        if (!player) {\r\n            // Reject the request:\r\n            this.processMoveExecute(desc);\r\n            return;\r\n        }\r\n        const dest = this.grid.tile.at(desc.dest.coord);\r\n        if (dest.isOccupied ||\r\n            dest.lastKnownUpdateId !== desc.dest.lastKnownUpdateId) {\r\n            // The update ID check is not essential, but it helps\r\n            // enforce stronger client-experience consistency: they cannot\r\n            // move somewhere where they have not realized the `LangSeq` has\r\n            // changed.\r\n            this.processMoveExecute(desc); // Reject the request.\r\n            return;\r\n        }\r\n\r\n        // Set response fields according to spec in `PlayerMovementEvent`:\r\n        desc.playerLastAcceptedRequestId = (1 + player.lastAcceptedRequestId);\r\n        desc.newPlayerHealth = {\r\n            score:  player.status.score  + dest.freeHealth,\r\n            health: player.status.health + dest.freeHealth,\r\n        };\r\n        desc.dest.lastKnownUpdateId = (1 + dest.lastKnownUpdateId);\r\n        this.currentFreeHealth -= dest.freeHealth;\r\n        desc.dest.newFreeHealth = 0;\r\n        desc.dest.newCharSeqPair = this.dryRunShuffleLangCharSeqAt(dest);\r\n        desc.tilesWithHealthUpdates = this.dryRunSpawnFreeHealth();\r\n\r\n        // Accept the request, and trigger calculation\r\n        // and enactment of the requested changes:\r\n        desc.eventId = this.getNextUnusedEventId();\r\n        this.processMoveExecute(desc);\r\n    }\r\n\r\n\r\n    /**\r\n     * @see PlayerActionEvent.Bubble\r\n     * @param desc - Is modified to describe changes to be made.\r\n     */\r\n    public processBubbleRequest(desc: PlayerActionEvent.Bubble): void {\r\n        // TODO.impl\r\n        // - If successful, make sure to lower the health field.\r\n        // - Make an abstract method in the OperatorPlayer class called in\r\n        //   the top-level input processor for it to trigger this event.\r\n        const bubbler = this.managerCheckGamePlayingRequest(desc);\r\n        if (!bubbler) {\r\n            // Reject the request:\r\n            this.processBubbleExecute(desc);\r\n            return;\r\n        }\r\n        desc.playerLastAcceptedRequestId = (1 + bubbler.lastAcceptedRequestId);\r\n\r\n        // We are all go! Do it.\r\n        desc.eventId = this.getNextUnusedEventId();\r\n        this.processBubbleExecute(desc);\r\n    }\r\n\r\n}\r\nObject.freeze(GameManager);\r\nObject.freeze(GameManager.prototype);\r\n","import { Game } from \"game/Game\";\r\n\r\nimport { OmHooks } from 'browser/OmHooks';\r\nimport type { Coord }           from \"floor/Tile\";\r\nimport { VisibleTile }          from \"floor/VisibleTile\";\r\nimport { VisibleGrid }          from \"floor/VisibleGrid\";\r\n\r\nimport type { Player }          from \"game/player/Player\";\r\nimport { OperatorPlayer }       from \"game/player/OperatorPlayer\";\r\nimport { VisiblePlayerStatus }  from \"game/player/VisiblePlayerStatus\";\r\nimport { ArtificialPlayer }     from \"game/player/ArtificialPlayer\";\r\n\r\nimport { GameManager } from \"game/__gameparts/Manager\";\r\n\r\n\r\ntype G = Game.Type.OFFLINE;\r\n\r\n/**\r\n *\r\n *\r\n * @extends Game\r\n */\r\nexport class OfflineGame<S extends Coord.System> extends GameManager<G,S> {\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    protected __getGridImplementation(coordSys: S): VisibleGrid.ClassIf<S> {\r\n        return VisibleGrid.getImplementation(coordSys);\r\n    }\r\n\r\n    /**\r\n     * _Does not call reset._\r\n     *\r\n     * @param gameDesc -\r\n     */\r\n    public constructor(gameDesc: Game.CtorArgs<G,S>) {\r\n        super(\r\n            Game.Type.OFFLINE, {\r\n            tileClass: VisibleTile,\r\n            playerStatusCtor: VisiblePlayerStatus,\r\n            }, gameDesc,\r\n        );\r\n        if (!this.operator) {\r\n            throw new Error(\"The Operator for an OfflineGame should be defined.\");\r\n        }\r\n        VisiblePlayerStatus.colourizeTeamMembers(this.teams, this.operator);\r\n\r\n        // =====================================\r\n        // CALL TO RESET\r\n        this.reset();\r\n        // =====================================\r\n\r\n        /* TODO.test This should be safe in a garbage-collection and\r\n        event-handler sense: Since the event handler is added to the\r\n        event-handler-list of the `.game-grid__impl-body` element as an\r\n        anonymous function, which makes it impossible to remove from\r\n        the list without a reference to that function. Luckily for us,\r\n        Grid.__VisibleGrid_super will automatically remove the old game-\r\n        grid__impl-body child, thus allowing it to be GC'ed, and its\r\n        event-handler function with it. */\r\n        this.grid.baseElem.addEventListener(\"keydown\", (ev): boolean => {\r\n            // console.log(`key: ${ev.key}, code: ${ev.code},`\r\n            // + ` keyCode: ${ev.keyCode}, char: ${ev.char},`\r\n            // + ` charCode: ${ev.charCode}`);\r\n            this.operator.processKeyboardInput(ev);\r\n            // Disable scroll-down via spacebar:\r\n            if (ev.keyCode === 32) {\r\n                ev.preventDefault();\r\n                return false;\r\n            }\r\n            return true;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    protected __createOperatorPlayer(desc: Player.CtorArgs): OperatorPlayer<S> {\r\n        return new OperatorPlayer<S>(this, desc);\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    protected __createArtifPlayer(desc: Player.CtorArgs): ArtificialPlayer<S> {\r\n        return ArtificialPlayer.of(this, desc);\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public setTimeout(callback: TimerHandler, millis: number, ...args: any[]): number {\r\n        return setTimeout(callback, millis, args);\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    public cancelTimeout(handle: number): void {\r\n        clearTimeout(handle);\r\n    }\r\n}\r\nObject.freeze(OfflineGame);\r\nObject.freeze(OfflineGame.prototype);\r\n","import type { Coord } from \"floor/Coord\";\r\nimport type { GameManager } from \"game/__gameparts/Manager\";\r\n\r\nimport { Player } from \"game/player/Player\";\r\nimport { ArtificialPlayer } from \"../ArtificialPlayer\";\r\n\r\n\r\n/**\r\n *\r\n * @extends ArtificialPlayer\r\n */\r\n// TODO.impl\r\nexport class Chaser<S extends Coord.System> extends ArtificialPlayer<S> {\r\n\r\n    protected constructor(game: GameManager<any,S>, desc: Player.CtorArgs) {\r\n        super(game, desc);\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    protected computeDesiredDestination(): Coord<S> {\r\n        //const humans = this.game.__players.HUMAN;\r\n        return undefined!;\r\n    }\r\n\r\n    /**\r\n     * @override\r\n     */\r\n    protected computeNextMovementTimer(): number {\r\n        return undefined!;\r\n    }\r\n}\r\nObject.freeze(Chaser);\r\nObject.freeze(Chaser.prototype);\r\n","require(\"../../assets/style/game/index.css\");\r\n\r\nimport { OmHooks }          from \"browser/OmHooks\";\r\nimport type { Coord }       from \"floor/Tile\";\r\nimport { Lang }             from \"utils/TypeDefs\";\r\nimport { OfflineGame }      from \"./OfflineGame\";\r\nimport { IndexTasks }       from \"game/IndexTasks\";\r\n\r\nIndexTasks.INIT_CLASS_REGISTRIES();\r\n\r\n// TODO.design override ctor args for each impl, and make it so they adapt input to pass to super ctor.\r\n// TODO.build this has been set to `var` for testing purposes. It should be `const` in production.\r\nexport const game = new OfflineGame<Coord.System.EUCLID2>({\r\n    coordSys: \"EUCLID2\" as Coord.System.EUCLID2,\r\n    gridDimensions: {\r\n        height: 21,\r\n        width:  21,\r\n    },\r\n    gridHtmlIdHook: OmHooks.Grid.Id.GRID,\r\n    averageFreeHealthPerTile: 1.0 / 70.0,\r\n    langBalancingScheme: Lang.BalancingScheme.WEIGHT,\r\n    languageName: \"engl-low\",\r\n    operatorIndex: 0,\r\n    playerDescs: [\r\n        {\r\n            familyId:   \"HUMAN\",\r\n            teamId:     0,\r\n            socketId:   undefined,\r\n            username:   \"hello world\",\r\n            noCheckGameOver: false,\r\n        },\r\n    ],\r\n});\r\n\r\n// Print some things:\r\n// console.log(game);\r\n// console.log(game.lang.simpleView());\r\n\r\ngame.statusBecomePlaying();\r\n"],"sourceRoot":""}